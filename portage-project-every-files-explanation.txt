bin/archive-conf
	# archive-conf -- save off a config file in the dispatch-conf archive dir
bin/bashrc-functions.sh
	# misc internal functions (success/die hook + strip dup slashes + get KV minor.major.micro)
bin/binhost-snapshot
    # "This program will copy src_pkg_dir to snapshot_dir and inside binhost_dir it will create a Packages index file "
    # "which refers to snapshot_uri. This is intended to solve race conditions on binhosts as described at http://crosbug.com/3225."
bin/chmod-lite
	# bash wrapper for bin/chmod-lite.py python script
bin/chmod-lite.py
	# Emulate 'chmod -fR a+rX,u+w,g-w,o-w' with minimal chmod calls.
bin/chpathtool.py
	# Helper tool for converting installed files to custom prefixes.
bin/clean_locks
	# specify directories with hardlink-locks to clean. (on the command line)
bin/dispatch-conf
	# dispatch-conf -- Integrate modified configs, post-emerge
bin/dohtml.py
	# will install the files in the list of files (space-separated list) into /usr/share/doc/${PF}/html
bin/doins.py
	# Core implementation of doins ebuild helper command. This script is designed to be executed by ebuild-helpers/doins.
bin/eapi.sh
	# eapi functions, phase numbers & prototypes
bin/eapi7-ver-funcs.sh
	# Eapi7 version tests, version compares, split, cut, parse.
bin/ebuild
	# Main script - you know this.
#EBUILD-HELPERS: These are each of all the granular functions for the EAPI functions, written in bash usually
bin/ebuild-helpers/bsd/sed
bin/ebuild-helpers/die
bin/ebuild-helpers/dobin
bin/ebuild-helpers/doconfd
bin/ebuild-helpers/dodir
bin/ebuild-helpers/dodoc
bin/ebuild-helpers/doenvd
bin/ebuild-helpers/doexe
bin/ebuild-helpers/dohard
bin/ebuild-helpers/doheader
bin/ebuild-helpers/dohtml
bin/ebuild-helpers/doinfo
bin/ebuild-helpers/doinitd
bin/ebuild-helpers/doins
bin/ebuild-helpers/dolib
bin/ebuild-helpers/dolib.a
bin/ebuild-helpers/dolib.so
bin/ebuild-helpers/doman
bin/ebuild-helpers/domo
bin/ebuild-helpers/dosbin
bin/ebuild-helpers/dosed
bin/ebuild-helpers/dosym
bin/ebuild-helpers/eerror
bin/ebuild-helpers/einfo
bin/ebuild-helpers/elog
bin/ebuild-helpers/emake
bin/ebuild-helpers/eqawarn
bin/ebuild-helpers/ewarn
bin/ebuild-helpers/fowners
bin/ebuild-helpers/fperms
bin/ebuild-helpers/keepdir
bin/ebuild-helpers/newbin
bin/ebuild-helpers/newconfd
bin/ebuild-helpers/newdoc
bin/ebuild-helpers/newenvd
bin/ebuild-helpers/newexe
bin/ebuild-helpers/newheader
bin/ebuild-helpers/newinitd
bin/ebuild-helpers/newins
bin/ebuild-helpers/newlib.a
bin/ebuild-helpers/newlib.so
bin/ebuild-helpers/newman
bin/ebuild-helpers/newsbin
bin/ebuild-helpers/nonfatal
bin/ebuild-helpers/portageq
bin/ebuild-helpers/prepall
bin/ebuild-helpers/prepalldocs
bin/ebuild-helpers/prepallinfo
bin/ebuild-helpers/prepallman
bin/ebuild-helpers/prepallstrip
bin/ebuild-helpers/prepinfo
bin/ebuild-helpers/prepman
bin/ebuild-helpers/prepstrip
bin/ebuild-helpers/unprivileged/chgrp
bin/ebuild-helpers/unprivileged/chown
bin/ebuild-helpers/xattr/install
#END EBUILD-HELPERS
#BIN/e*
bin/ebuild-ipc
	# wrapper stub to call ebuild-ipc.py
bin/ebuild-ipc.py
	# This is a helper which ebuild processes can use to communicate with portage's main python process.
bin/ebuild-pyhelper
	# seems to be symlinked to bin/ebuild-ipc which calls bin/ebuild-ipc.py
bin/ebuild.sh
#***# main builder program
bin/ecompress
	# handle compressing of files, PORTAGE_COMPRESS , PORTAGE_COMPRESS_FLAGS , PORTAGE_COMPRESS_SUFFIX
bin/ecompress-file
	# compress_file() calls ecompress
bin/egencache
	# egencache - generate metadata cache for ebuild repositories
bin/emaint
#&&&# Main """System health checks and maintenance utilities.""" program
bin/emerge
#***# Main merge program
bin/emerge-webrsync
#   # Main sync program
bin/emirrordist
	# wrapper stub to call emirrordist_main()
bin/env-update
	# env-update - updates environment settings automatically
    # env-update  reads the files in /etc/env.d and automatically generates /etc/profile.env and /etc/ld.so.conf.
	# Then ldconfig(8) is run to update /etc/ld.so.cache.  env-update is run by emerge(1) automatically after each package merge.
    # Also, if you make  changes  to  /etc/env.d, you  should  run env-update yourself for changes to take effect immediately. 
bin/estrip
	# estrip queue/dequeue for dostrip logic, toolchain involvement
	# prepstrip for scanelf checks in install_qa_check
	# preserve_xattr in xattr-helper.py
	# save_elf_sources(), save_elf_debug(), process_elf(), process_ar()
bin/etc-update
	# etc-update - handle configuration file updates
    #USAGE: etc-update [options] [--automode <mode>] [paths to scan]
	#etc-update  is  supposed to be run after merging a new package to see if there are updates to the configuration files. 
	#   		 If a new configuration file will override an old one, etc-update will prompt the user for a decision.
bin/filter-bash-environment.py
	# Filter out variable assignments for variable vnames matching a given PATTERN while leaving bash function definitions and here-documents intact.
	# The PATTERN is a space separated list of variable names and it supports python regular expression syntax.
bin/fixpackages
	# fixpackages -- performs package move updates on configuration files, installed packages, and binary packages.
bin/glsa-check
	# usage: glsa-check <option> [glsa-id | all | new | affected]
	# List a summary for the given GLSA(s) or set and whether they affect the system
	#Modes:
	#  -l, --list        List a summary for the given GLSA(s) or set and whether they affect the system
	#  -d, --dump        Show all information about the GLSA(s) or set
	#  --print           Alias for --dump
	#  -t, --test        Test if this system is affected by the GLSA(s) or set and output the GLSA ID(s)
	#  -p, --pretend     Show the necessary steps to remediate the system
	#  -f, --fix         (experimental) Attempt to remediate the system based on the instructions given in the GLSA(s) or set. This will only upgrade
	#                    (when an upgrade path exists) or remove packages
	#  -i, --inject      Inject the given GLSA(s) into the glsa_injected file
	#  -m, --mail        Send a mail with the given GLSAs to the administrator
bin/gpkg-helper.py
	# usage: compose <package_cpv> <binpkg_path> <metadata_dir> <image_dir>"
	# internal gpkg package file+metadata compression creation helper, no signing yet
bin/gpkg-sign
	# usage: gpkg-sign [options] <gpkg package file>
	# requires "BINPKG_GPG_SIGNING_GPG_HOME" and "BINPKG_GPG_SIGNING_KEY" set
bin/helper-functions.sh
	# For routines we want to use in ebuild-helpers/ but don't want to expose to the general ebuild environment.
	## API functions for doing parallel processing
	__multijob_init() __multijob_post_fork()
	## Find a free fd and redirect the specified file via it.
	__redirect_alloc_fd()
#BEGIN INSTALL-QA-Helper Functions
bin/preinst-qa-check.d/50xdg-utils
bin/postinst-qa-check.d/50xdg-utils
	# Check for missing calls to xdg-utils regen functions
	xdg_desktop_database_check()
bin/install-qa-check.d/05double-D
	# Check for accidential install into ${D}/${D}
	DD_check()
bin/install-qa-check.d/05prefix
	# Prefix specific QA checks
	install_qa_check_prefix()
bin/install-qa-check.d/10executable-issues
	# Check for major issues with built executables: insecure RPATHs, text relocations, executable stacks
	elf_check()
bin/install-qa-check.d/10ignored-flags
	# QA checks for ignored *FLAGS.
	ignored_flag_check()
bin/install-qa-check.d/20deprecated-directories
	# Check for deprecated directories
	deprecated_dir_check()
bin/install-qa-check.d/20runtime-directories
	# Check for directories that need to be created at runtime
	runtime_dir_check()
bin/install-qa-check.d/60bash-completion
	# QA checks for bash-completion files
	bashcomp_check()
bin/install-qa-check.d/60openrc
	# QA checks for OpenRC init.d files.
	openrc_check()
bin/install-qa-check.d/60pkgconfig
	# Check for pkg-config file issues
	pkgconfig_check()
bin/install-qa-check.d/60pngfix
	# Check for issues with PNG files
	pngfix_check()
bin/install-qa-check.d/60systemd
	# QA checks for systemd units.
	systemd_check()
bin/install-qa-check.d/60udev
	# Check udev rule installs
	udev_check()
bin/install-qa-check.d/80libraries
	# Check for issues with installed libraries
	scanelf_lib_check()
bin/install-qa-check.d/80multilib-strict
	# Strict multilib directory checks
	multilib_strict_check()
bin/install-qa-check.d/90bad-bin-group-write
	# Warn about globally-installed executables (in /bin, /usr/bin, /sbin,
	# /usr/sbin, or /opt/bin) that are group-writable by a nonzero GID.
	#
	# This check doesn't work on non-root prefix installations at
	# the moment, because every executable therein is owned by a nonzero GID.
	bad_bin_group_write_check()
bin/install-qa-check.d/90bad-bin-owner
	# Warn about globally-installed executables (in /bin, /usr/bin, /sbin,
	# /usr/sbin, or /opt/bin) that are owned by a nonzero UID.
	#
	# This check doesn't work on non-root prefix installations at
	# the moment, because every executable therein is owned by a nonzero UID.
	bad_bin_owner_check()
bin/install-qa-check.d/90cmake-warnings
	# Check for CMake invalid option warnings
	cmake_warn_check()
bin/install-qa-check.d/90config-impl-decl
	# Check for implicit function declaration warnings in configure logs
	# ebuilds should set the QA_CONFIG_IMPL_DECL_SKIP array to skip known false positives.
	config_impl_decl_check()
bin/install-qa-check.d/90cython-dep
	# Check for missing dev-python/cython dep based on output from setuptools cythonize() support
	cython_dep_check()
bin/install-qa-check.d/90gcc-warnings
	# Check for important gcc warnings
	gcc_warn_check()
bin/install-qa-check.d/90world-writable
	# Check for world-writable files
	world_writable_check()
bin/install-qa-check.d/95empty-dirs
	# Warn about and/or remove empty directories installed by ebuild.
	find_empty_dirs()
#END INSTALL-QA-Helper Functions
bin/install.py
	# wrap the install binary for compatibility, including copy_xattrs()
bin/isolated-functions.sh
	# internal signal wrapper stdin handler bash pipe debug trace stuff ....
	# also eqawarn , elog , einfo , ewarn, eerror, ebegin, eend, debug-print()
bin/lock-helper.py
    # Make locks quiet since unintended locking messages displayed on stdout would corrupt the intended output of this program.
bin/meson.build
	# own build config, says which dir these binaries get installed to
bin/misc-functions.sh
	# Miscellaneous shell functions that make use of the ebuild env but don't need to be included directly in ebuild.sh.
	install_symlink_html_docs()
	canonicalize()
	install_qa_check()
	preinst_qa_check()
	postinst_qa_check()
	preinst_mask()
	preinst_sfperms()
	preinst_suid_scan()
	preinst_selinux_labels()
	die_hooks()
	success_hooks()
	install_hooks()
	eqatag()
bin/phase-functions.sh
	# Read an environment from stdin and echo to stdout while filtering variables with names that are known to cause interference
	__filter_readonly_variables()
	# Filter any readonly variables from ${T}/environment, source it, and then save it via __save_ebuild_env().
	__preprocess_ebuild_env()
	# abstract prototypes
	__ebuild_phase()
	__ebuild_phase_with_hooks()
	# It appears that '${PF}' is already prepared; skipping.
	# Remove '${PORTAGE_BUILDDIR}/.pretended' to force pretend.
	__dyn_pretend()
	# Remove '${PORTAGE_BUILDDIR}/.setuped' to force setup.
	__dyn_setup()
	# ">>> Source unpacked in ${WORKDIR}"
	__dyn_unpack()
	__dyn_clean()
	__abort_handler()
	__abort_prepare()
	__abort_configure()
	__abort_compile()
	__abort_test()
	__abort_install()
	__has_phase_defined_up_to()
	# Remove '${PORTAGE_BUILDDIR}/.prepared' to force prepare.
	__dyn_prepare()
	# Remove '${PORTAGE_BUILDDIR}/.configured' to force configuration.
	__dyn_configure()
	# Remove '${PORTAGE_BUILDDIR}/.compiled' to force compilation.
	__dyn_compile()
	# Remove '${PORTAGE_BUILDDIR}/.tested' to force test.
	__dyn_test()
	# Remove '${PORTAGE_BUILDDIR}/.installed' to force install.
	__dyn_install()
	# How to use the ebuild command (unused)
	__dyn_help()
	# Translate a known ebuild(1) argument into the precise name of it's corresponding ebuild phase.
	__ebuild_arg_to_phase()
	__ebuild_phase_funcs()
	# Run all the phases
	__ebuild_main()
bin/phase-helpers.sh
	into()
	insinto()
	exeinto()
	docinto()
	insopts()
	diropts()
	exeopts()
	libopts()
	docompress()
	dostrip()
	useq()
	usev()
	use()
	use_with()
	use_enable()
	unpack()
	econf()
	einstall()
	has_version()
	best_version()
bin/pid-ns-init
	# PID namespace init python starter script
 	# Usage: {} <main-child-pid> or <uid> <gid> <groups> <umask> <pass_fds> <binary> <argv0> [arg]..
bin/portageq
	# > Portage information query tool
bin/portageq-wrapper
	# stub wrapper
bin/quickpkg
	# quickly zip up installed system files on root dir and reverse make them into new packages for reuse
	# usage: quickpkg [options] <list of package atoms or package sets>
bin/regenworld
    # regenerates the portage world file by checking the portage logfile for all actions that you've done in the past
bin/save-ebuild-env.sh
	# echo the current environment to stdout, filtering out redundant info.
	__save_ebuild_env()
bin/shelve-utils
	# dump & restore shelve database (shelve<->pickle converter)
bin/socks5-server.py
	# An asynchronous SOCKSv5 server. Handle incoming client connection.
	# Perform SOCKSv5 request exchange, open a proxied connection and start relaying.
bin/xattr-helper.py
	# Dump and restore extended attributes.
	#  Dump the values of all extended attributes associated with paths passed as arguments or null-separated paths read from stdin.
	#  Restore extended attributes using " "a dump read from stdin.
	#def dump_xattrs(pathnames, file_out):
	#  Dump the xattr data for |pathnames| to |file_out|
	#def restore_xattrs(file_in):
    #  Read |file_in| and restore xattrs content from it
bin/xpak-helper.py
	# Perform metadata operations on a binary package.
	# usage: recompose <binpkg_path> <metadata_dir>
lib/_emerge/resolver/__init__.py
lib/_emerge/resolver/meson.build
	# ( system build script, config for installing this package )
lib/_emerge/resolver/DbapiProvidesIndex.py
lib/_emerge/resolver/backtracking.py
lib/_emerge/resolver/circular_dependency.py
lib/_emerge/resolver/output.py
lib/_emerge/resolver/output_helpers.py
lib/_emerge/resolver/package_tracker.py
lib/_emerge/resolver/slot_collision.py
lib/_emerge/__init__.py
	# python module - empty.
lib/_emerge/meson.build
	# ( system build script, config for installing this package )
lib/_emerge/AbstractDepPriority.py
	#class AbstractDepPriority(SlotObject):
    #    __slots__ = (
    #        "buildtime",
    #        "buildtime_slot_op",
    #        "runtime",
    #        "runtime_post",
    #        "runtime_slot_op",
	# >=, !=, ==, <= comparison operators
	# stub class
lib/_emerge/AbstractEbuildProcess.py
	#class AbstractEbuildProcess(SpawnProcess):
lib/_emerge/AbstractPollTask.py
	#class AbstractPollTask(AsynchronousTask):
lib/_emerge/AsynchronousLock.py
	#class AsynchronousLock(AsynchronousTask):
lib/_emerge/AsynchronousTask.py
	#class AsynchronousTask(SlotObject):
lib/_emerge/AtomArg.py
	#class AtomArg(DependencyArg):
    #	__slots__ = ("atom", "pset")
	# stub class
lib/_emerge/Binpkg.py
	#class Binpkg(CompositeTask):
lib/_emerge/BinpkgEnvExtractor.py
	#class BinpkgEnvExtractor(CompositeTask):
	#	Extract environment.bz2 for a binary or installed package.
lib/_emerge/BinpkgExtractorAsync.py
	#class BinpkgExtractorAsync(SpawnProcess):
	#	__slots__ = ("features", "image_dir", "pkg", "pkg_path")
lib/_emerge/BinpkgFetcher.py
	#class BinpkgFetcher(CompositeTask):
	#	__slots__ = ("pkg", "pretend", "logfile", "pkg_path", "pkg_allocated_path")
lib/_emerge/BinpkgPrefetcher.py
	#class BinpkgPrefetcher(CompositeTask):
	#    __slots__ = ("pkg",) + ( "pkg_path",  "pkg_allocated_path", "_bintree" )
lib/_emerge/BinpkgVerifier.py
	#class BinpkgVerifier(CompositeTask):
	#    __slots__ = ("logfile", "pkg", "_digests", "_pkg_path")
lib/_emerge/Blocker.py
	#class Blocker(Task):
	#	__slots__ = ("root", "atom", "cp", "eapi", "priority", "satisfied")
	# stub class
lib/_emerge/BlockerCache.py
	#class BlockerCache(portage.cache.mappings.MutableMapping):
    #    This caches blockers of installed packages so that dep_check does not
	#	 have to be done for every single installed package on every invocation of emerge.
	#    The cache is invalidated whenever it is detected that something
	#    has changed that might alter the results of dep_check() calls:
lib/_emerge/BlockerDB.py
	#class BlockerDB:
	#    def findInstalledBlockers(self, new_pkg):
	#        Search for installed run-time blockers in the root where
	#        new_pkg is planned to be installed. This ignores build-time
	#        blockers, since new_pkg is assumed to be built already.
	#	 def discardBlocker(self, pkg):
    #		 Discard a package from the list of potential blockers.
	#		 This will match any package(s) with identical cpv or cp:slot.
lib/_emerge/BlockerDepPriority.py
	#class BlockerDepPriority(DepPriority):
	# stub class
lib/_emerge/CompositeTask.py
	#class CompositeTask(AsynchronousTask):
	#    __slots__ = ("_current_task",)
	# + several method functions
lib/_emerge/DepPriority.py
	#class DepPriority(AbstractDepPriority):
	#    __slots__ = ("satisfied", "optional", "ignored")
	#        Note: These priorities are only used for measuring hardness in the circular dependency display via digraph.debug_print(), and nothing more.
	#		 For actual merge order calculations, the measures defined by the DepPriorityNormalRange and DepPrioritySatisfiedRange classes are used.
	#        Attributes                       Hardness
    #    buildtime_slot_op                       0
    #    buildtime                              -1
    #    runtime                                -2
    #    runtime_post                           -3
    #    optional                               -4
    #    (none of the above)                    -5
lib/_emerge/DepPriorityNormalRange.py
	#class DepPriorityNormalRange:
	#    DepPriority properties              Index      Category
	#    buildtime                                      HARD
	#    runtime                                3       MEDIUM
	#    runtime_post                           2       MEDIUM_SOFT
	#    optional                               1       SOFT
	#    (none of the above)                    0       NONE
lib/_emerge/DepPrioritySatisfiedRange.py
	#class DepPrioritySatisfiedRange:
	#    DepPriority                         Index      Category
	#    not satisfied and buildtime                    HARD
	#    not satisfied and runtime              7       MEDIUM
	#    satisfied and buildtime_slot_op        6       MEDIUM_SOFT
	#    satisfied and buildtime                5       MEDIUM_SOFT
	#    satisfied and runtime                  4       MEDIUM_SOFT
	#    runtime_post                           3       MEDIUM_POST
	#    satisfied and runtime_post             2       MEDIUM_POST
	#    optional                               1       SOFT
	#    (none of the above)                    0       NONE
lib/_emerge/Dependency.py
	#class Dependency(SlotObject):
    #    __slots__ = (
    #        "atom",
    #        "blocker",
    #        "child",
    #        "depth",
    #        "parent",
    #        "onlydeps",
    #        "priority",
    #        "root",
    #        "want_update",
    #        "collapsed_parent",
    #        "collapsed_priority", )
lib/_emerge/DependencyArg.py
	#class DependencyArg:
	#    __slots__ = (	"arg", "force_reinstall", "internal", "reset_depth", "root_config")
lib/_emerge/EbuildBinpkg.py
	#class EbuildBinpkg(CompositeTask):
	#    This assumes that src_install() has successfully completed.
    #    __slots__ = (	"pkg", "settings") + (
    #        "_binpkg_tmpfile",
    #        "_binpkg_info",
    #        "pkg_allocated_path", )
lib/_emerge/EbuildBuild.py
	#class EbuildBuild(CompositeTask):
    #    __slots__ = (
    #        "args_set",
    #        "config_pool",
    #        "find_blockers",
    #        "ldpath_mtimes",
    #        "logger",
    #        "opts",
    #        "pkg",
    #        "pkg_count",
    #        "prefetcher",
    #        "settings",
    #        "world_atom",
    #    ) + ("_build_dir", "_buildpkg", "_ebuild_path", "_issyspkg", "_tree")
lib/_emerge/EbuildBuildDir.py
	#class EbuildBuildDir(SlotObject):
	#    __slots__ = (	"scheduler", "settings", "locked", "_catdir", "_lock_obj")
lib/_emerge/EbuildExecuter.py
	#class EbuildExecuter(CompositeTask):
	#    __slots__ = (	"pkg", "settings")
	#    _phases = (	"prepare", "configure", "compile", "test", "install")
lib/_emerge/EbuildFetcher.py
	#class EbuildFetcher(CompositeTask):
    #    __slots__ = (
    #        "config_pool",
    #        "ebuild_path",
    #        "fetchonly",
    #        "fetchall",
    #        "logfile",
    #        "pkg",
    #        "prefetch",
    #        "_fetcher_proc", )
	#   def async_already_fetched(self, settings):
    #	    Returns True if all files already exist locally and have correct digests, otherwise return False.
lib/_emerge/EbuildFetchonly.py
	#class EbuildFetchonly(SlotObject):
	#    __slots__ = (	"fetch_all", "pkg", "pretend", "settings")
lib/_emerge/EbuildIpcDaemon.py
	#class EbuildIpcDaemon(FifoIpcDaemon):
	#    This class serves as an IPC daemon, which ebuild processes can use to communicate with portage's main python process.
	#    __slots__ = (	"commands",)
lib/_emerge/EbuildMerge.py
	#class EbuildMerge(CompositeTask):
    #    __slots__ = (
    #        "exit_hook",
    #        "find_blockers",
    #        "logger",
    #        "ldpath_mtimes",
    #        "pkg",
    #        "pkg_count",
    #        "pkg_path",
    #        "postinst_failure",
    #        "pretend",
    #        "settings",
    #        "tree",
    #        "world_atom",
lib/_emerge/EbuildMetadataPhase.py
	#class EbuildMetadataPhase(SubProcess):
	#    Asynchronous interface for the ebuild "depend" phase which is used to extract metadata from the ebuild.
	#    __slots__ = (
	#        "cpv",
	#        "eapi_supported",
	#        "ebuild_hash",
	#        "fd_pipes",
	#        "metadata",
	#        "portdb",
	#        "repo_path",
	#        "settings",
	#        "write_auxdb",
	#        "_eapi",
	#        "_eapi_lineno",
	#        "_raw_metadata", )
lib/_emerge/EbuildPhase.py
	#class EbuildPhase(CompositeTask):
	#    __slots__ = (	"actionmap", "fd_pipes", "phase", "settings") + ("_ebuild_lock",)
#***# Main Program file
lib/_emerge/EbuildProcess.py
	#class EbuildProcess(AbstractEbuildProcess):
	#    __slots__ = (	"actionmap",)
	#	"portage.package.ebuild.doebuild:_doebuild_spawn,_spawn_actionmap"
lib/_emerge/EbuildSpawnProcess.py
	#class EbuildSpawnProcess(AbstractEbuildProcess):
	#    __slots__ = (	"fakeroot_state", "spawn_func")
	#    Used by doebuild.spawn() to manage the spawned process.
lib/_emerge/FakeVartree.py
	#class FakeVardbGetPath:
	#    Implements the vardbapi.getpath() method which is used in error handling
	#    code for the Package class and vartree.get_provide().
	#class FakeVartree(vartree):
	#    This is implements an in-memory copy of a vartree instance that provides
	#    all the interfaces required for use by the depgraph. 
lib/_emerge/FifoIpcDaemon.py
	#class FifoIpcDaemon(AbstractPollTask):
	#    __slots__ = (	"input_fifo", "output_fifo", "_files")
lib/_emerge/JobStatusDisplay.py
	#class JobStatusDisplay:
	#   _bound_properties = ("curval", "failed", "running")
	#		Don't update the display unless at least this much time has passed, in units of seconds.
	#_	min_display_latency = 2
	# display output , load average, jobs display status
lib/_emerge/MergeListItem.py
	#class MergeListItem(CompositeTask):
	#    __slots__ = (
	#        "args_set",
	#        "binpkg_opts",
	#        "build_opts",
	#        "config_pool",
	#        "emerge_opts",
	#        "find_blockers",
	#        "logger",
	#        "mtimedb",
	#        "pkg",
	#        "pkg_count",
	#        "pkg_to_replace",
	#        "prefetcher",
	#        "settings",
	#        "statusMessage",
	#        "world_atom",
	#    ) + ("_install_task",)
lib/_emerge/MetadataRegen.py
	#class MetadataRegen(AsyncScheduler):
lib/_emerge/MiscFunctionsProcess.py
	#class MiscFunctionsProcess(AbstractEbuildProcess):
	#    Spawns misc-functions.sh with an existing ebuild environment.
lib/_emerge/Package.py
	#class Package(Task):
	# lots of stuff
lib/_emerge/PackageArg.py
	#class PackageArg(DependencyArg):
lib/_emerge/PackageMerge.py
	#class PackageMerge(CompositeTask):
	#    __slots__ = ("merge", "postinst_failure")
lib/_emerge/PackagePhase.py
	#class PackagePhase(CompositeTask):
	#    Invokes the package phase and handles PKG_INSTALL_MASK.
	#    __slots__ = (
	#        "actionmap",
	#        "fd_pipes",
	#        "logfile",
	#        "settings",
	#        "_pkg_install_mask",
	#        "_proot",    )
lib/_emerge/PackageUninstall.py
	#class PackageUninstall(CompositeTask):
	#    Uninstall a package asynchronously in a subprocess. When both parallel-install and ebuild-locks FEATURES are enabled,
	#    it is essential for the ebuild-locks code to execute in a subprocess, since the portage.locks module does not behave
	#    as desired if we try to lock the same file multiple times concurrently from the same process for ebuild-locks phases
	#    such as pkg_setup, pkg_prerm, and pkg_postrm.
	#    __slots__ = (
	#        "world_atom",
	#        "ldpath_mtimes",
	#        "opts",
	#        "pkg",
	#        "settings",
	#        "_builddir_lock",    )
lib/_emerge/PackageVirtualDbapi.py
	#class PackageVirtualDbapi(dbapi):
	#    A dbapi-like interface class that represents the state of the installed package database as new packages are installed,
	# 	 replacing any packages that previously existed in the same slot. The main difference between this class and fakedbapi 
	# 	 is that this one uses Package instances internally (passed in via cpv_inject() and cpv_remove() calls).
lib/_emerge/PipeReader.py
	#class PipeReader(AbstractPollTask):
	#    Reads output from one or more files and saves it in memory, for retrieval via the getvalue() method.
	#	 This is driven by the scheduler's poll() loop, so it runs entirely within the current process.
lib/_emerge/PollScheduler.py
	#class PollScheduler:
    # max time between loadavg checks (milliseconds)
	# (maybe related to lib/_emerge/JobStatusDisplay.py )
lib/_emerge/ProgressHandler.py
	#class ProgressHandler:
	# (related to PollScheduler.py & JobStatusDisplay.py )
lib/_emerge/RootConfig.py
	#class RootConfig:
    #	This is used internally by depgraph to track information about a particular $ROOT.
	#    __slots__ = (	"mtimedb", "root", "setconfig", "sets", "settings", "trees")
	#    pkg_tree_map = {	"ebuild": "porttree", "binary": "bintree", "installed": "vartree"}
lib/_emerge/Scheduler.py
	# huge file
lib/_emerge/SequentialTaskQueue.py
	#class SequentialTaskQueue(SlotObject):
	#    __slots__ = ("max_jobs", "running_tasks") + ("_scheduling", "_task_queue")
lib/_emerge/SetArg.py
	#class SetArg(DependencyArg):
	#    __slots__ = ("name", "pset")
lib/_emerge/SpawnProcess.py
    #class SpawnProcess(SubProcess):
    #    Constructor keyword args are passed into portage.process.spawn().
    #    The required "args" keyword argument will be passed as the first spawn() argument.
    #    _spawn_kwarg_names = (
    #        "env",
    #        "opt_name",
    #        "fd_pipes",
    #        "uid",
    #        "gid",
    #        "groups",
    #        "umask",
    #        "logfile",
    #        "path_lookup",
    #        "pre_exec",
    #        "close_fds",
    #        "unshare_ipc",
    #        "unshare_mount",
    #        "unshare_pid",
    #        "unshare_net",  )
    #    __slots__ = (
    #        ("args", "log_filter_file")
    #        + _spawn_kwarg_names
    #        + ( "_main_task",
    #            "_main_task_cancel",
	#            "_selinux_type",     )    )
lib/_emerge/SubProcess.py
    #class SubProcess(AbstractPollTask):
    #    __slots__ = ("pid",) + ("_dummy_pipe_fd", "_files", "_waitpid_id")
    #    _cancel_timeout = 1  # seconds # This is how much time we allow for waitpid to succeed after we've sent a kill signal to our subprocess.
	#	_async_wait(), _async_waitpid(), _async_waitpid_cb()
lib/_emerge/Task.py
	#class Task(SlotObject):
	#    __slots__ = ("_hash_key", "_hash_value")
	# abstract class
lib/_emerge/TaskSequence.py
    #class TaskSequence(CompositeTask):
    #    A collection of tasks that executes sequentially. Each task must have a addExitListener() method 
	#	 that can be used as a means to trigger movement from one task to the next.
    #    __slots__ = ("_task_queue",)
lib/_emerge/UninstallFailure.py
	#class UninstallFailure(portage.exception.PortageException):
	#    An instance of this class is raised by unmerge() when an uninstallation fails.
lib/_emerge/UnmergeDepPriority.py
    #class UnmergeDepPriority(AbstractDepPriority):
    #    __slots__ = (
    #        "ignored",
    #        "optional",
    #        "satisfied",    )
    #	Combination of properties           Priority  Category
    #	runtime_slot_op                        0       HARD
    #	runtime                               -1       HARD
    #	runtime_post                          -2       HARD
    #	buildtime                             -3       SOFT
    #	(none of the above)                   -3       SOFT
lib/_emerge/UseFlagDisplay.py
	#class UseFlagDisplay:
	#    __slots__ = ("name", "enabled", "forced")
lib/_emerge/UserQuery.py
	#class UserQuery:
	#  	The UserQuery class is used to prompt the user with a set of responses, as well as accepting and handling the responses.
lib/_emerge/_find_deep_system_runtime_deps.py
	#def _find_deep_system_runtime_deps(graph):
lib/_emerge/_flush_elog_mod_echo.py
    #Dump the mod_echo output now so that our other notifications are shown last.
	#def _flush_elog_mod_echo():
	#	mod_echo.finalize()
lib/_emerge/actions.py
#***# huge 4000 line file mostly original style
    #def action_build(
    #def action_config(settings, trees, myopts, myfiles):
    #def action_depclean(
    #def calc_depclean(settings, trees, ldpath_mtimes, myopts, action, args_set, spinner):
    #def _calc_depclean(settings, trees, ldpath_mtimes, myopts, action, args_set, spinner):
    #def action_deselect(settings, trees, opts, atoms):
    #class _info_pkgs_ver:
    #def action_info(settings, trees, myopts, myfiles):
    #def action_regen(settings, portdb, max_jobs, max_load):
    #def action_search(root_config, myopts, myfiles, spinner):
    #def action_sync(
    #def action_uninstall(settings, trees, ldpath_mtimes, opts, action, files, spinner):
    #def adjust_configs(myopts, trees):
    #def adjust_config(myopts, settings):
    #def display_missing_pkg_set(root_config, set_name):
    #def relative_profile_path(portdir, abs_profile):
    #def get_libc_version(vardb: portage.dbapi.vartree.vardbapi) -> list[str]:
    #def get_profile_version(
    #def getportageversion(
    #class _emerge_config(SlotObject):
    #def load_emerge_config(emerge_config=None, env=None, **kargs):
    #def getgccversion(chost=None):
    #def validate_ebuild_environment(trees):
    #def check_procfs():
    #def config_protect_check(trees):
    #def apply_priorities(settings):
    #def nice(settings):
    #def ionice(settings):
    #def set_scheduling_policy(settings):
    #def setconfig_fallback(root_config):
    #def get_missing_sets(root_config):
    #def missing_sets_warning(root_config, missing_sets):
    #def ensure_required_sets(trees):
    #def expand_set_arguments(myfiles, myaction, root_config):
    #def repo_name_check(trees):
    #def repo_name_duplicate_check(trees):
    #def run_action(emerge_config):
lib/_emerge/chk_updated_cfg_files.py
	#def chk_updated_cfg_files(eroot, config_protect):
	#    result = list(portage.util.find_updated_config_files(target_root, config_protect))
	#    Notify in colorized output, when config Files Need Updating
lib/_emerge/clear_caches.py
	#def clear_caches(trees):
	#   d["porttree"].dbapi.melt()
	#   d["porttree"].dbapi._aux_cache.clear()
	#   d["bintree"].dbapi._clear_cache()
	#	d["vartree"].dbapi._linkmap._clear_cache()
lib/_emerge/countdown.py
	#def countdown(secs=5, doing="Starting"):
	#	">>> Waiting {secs} seconds before starting...\n"
lib/_emerge/create_depgraph_params.py
	#def create_depgraph_params(myopts, myaction):
    # configure emerge engine parameters
lib/_emerge/create_world_atom.py
	#def create_world_atom(pkg, args_set, root_config, before_install=False):
	#	Create a new atom for the world file if one does not exist.  If the argument atom is precise enough to identify a specific slot then a slot atom 
	#	will be returned. Atoms that are in the system set may also be stored in world since a user might want to select multiple slots of a slotted package 
	#	like gcc for example. Unslotted system packages will not be stored in world.
lib/_emerge/depgraph.py
	# Exposes a depgraph interface to dep_check.
	#	_dep_check_graph_interface = collections.namedtuple("_dep_check_graph_interface", (
	#        # Checks if parent package will replace child.
	#        "will_replace_child",
	#        # Indicates a removal action, like depclean or prune.
	#        "removal_action",
	#        # Checks if update is desirable for a given package.
	#        "want_update_pkg",	),	)
lib/_emerge/emergelog.py
	# We disable emergelog by default, since it's called from dblink.merge() 
	# and we don't want that to trigger log writes unless it's really called via emerge.
lib/_emerge/getloadavg.py
	# Uses /proc/loadavg to emulate os.getloadavg() (if missing).  Raises OSError if the load average was unobtainable.
lib/_emerge/help.py
	#def emerge_help():
	#    print(bold("emerge:") + " command-line interface to the Portage system")
	#    print(bold("Usage:"))
lib/_emerge/is_valid_package_atom.py
	#def insert_category_into_atom(atom, category):
    #	Handle '*' character for "extended syntax" wildcard support.
	#def is_valid_package_atom(x, allow_repo=False, allow_build_id=True):
lib/_emerge/main.py
#***# Main Main Program
    #options = [
    #    "--alphabetical",
    #    "--ask-enter-invalid",
    #    "--buildpkgonly",
    #    "--changed-use",
    #    "--columns",
    #    "--debug",
    #    "--digest",
    #    "--emptytree",
    #    "--verbose-conflicts",
    #    "--fetchonly",
    #    "--fetch-all-uri",
    #    "--ignore-default-opts",
    #    "--noconfmem",
    #    "--newrepo",
    #    "--newuse",
    #    "--nodeps",
    #    "--noreplace",
    #    "--nospinner",
    #    "--oneshot",
    #    "--onlydeps",
    #    "--pretend",
    #    "--quiet-repo-display",
    #    "--quiet-unmerge-warn",
    #    "--resume",
    #    "--searchdesc",
    #    "--skipfirst",
    #    "--tree",
    #    "--unordered-display",
    #    "--update",
    #    "--update-if-installed",	]
    #shortmapping = {
    #    "1": "--oneshot",
    #    "B": "--buildpkgonly",
    #    "c": "--depclean",
    #    "C": "--unmerge",
    #    "d": "--debug",
    #    "e": "--emptytree",
    #    "f": "--fetchonly",
    #    "F": "--fetch-all-uri",
    #    "h": "--help",
    #    "n": "--noreplace",
    #    "N": "--newuse",
    #    "o": "--onlydeps",
    #    "O": "--nodeps",
    #    "p": "--pretend",
    #    "P": "--prune",
    #    "r": "--resume",
    #    "s": "--search",
    #    "S": "--searchdesc",
    #    "t": "--tree",
    #    "u": "--update",
    #    "U": "--changed-use",
    #    "V": "--version",	}
#***# Main Main Program
lib/_emerge/post_emerge.py
	#def clean_logs(settings):
	#def display_news_notification(root_config, myopts):
	#def show_depclean_suggestion():
	#def post_emerge(myaction, myopts, myfiles, target_root, trees, mtimedb, retval):
lib/_emerge/search.py
	# original style code very long search function
#***# Main Search Program
lib/_emerge/show_invalid_depstring_notice.py
	#def show_invalid_depstring_notice(parent_node, error_msg):
	#	msg1 = ( "\n\n!!! Invalid or corrupt dependency specification: "
	#	msg.append("Portage is unable to process the dependencies of the package ")
lib/_emerge/stdout_spinner.py
	#class stdout_spinner:
	#    scroll_msgs = [	"3.1415926535897932384626433832795028841971694",	#        "Inaccuracy saves a world of explanation.",
	#	 twirl_sequence = "/-\\|/-\\|/-\\|/-\\|\\-/|\\-/|\\-/|\\-/|"
	# update display, scroll, spin, basic, early, quiet
lib/_emerge/unmerge.py
	#def _unmerge_display(
	#def unmerge(
#***# Main Unmerge Program
lib/meson.build
	# ( system build script, config for installing this package )
lib/portage/__init__.py
#***# Main Init Initialize Portage Program
	# lots of stuff is in this , imports, dependencies, unicode, forkwatcher, createtrees, = boilerplate set up and inits
lib/portage/_compat_upgrade/__init__.py	# empty
lib/portage/_emirrordist/meson.build
	# ( system build script, config for installing this package )
lib/portage/_compat_upgrade/binpkg_compression.py
	#COMPAT_BINPKG_COMPRESS = "bzip2"
	#	If the current installation is still configured to use the old default BINPKG_COMPRESS=bzip2 setting,
	#	then patch make.globals inside ${ED} to maintain backward compatibility,
lib/portage/_compat_upgrade/binpkg_multi_instance.py
	#COMPAT_FEATURES = 'FEATURES="${FEATURES} -binpkg-multi-instance"'
	#    If the current installation is still has binpkg-multi-instance disabled, 
	#	 then patch make.globals inside ${ED} to maintain backward compatibility.
lib/portage/_compat_upgrade/default_locations.py
	#COMPAT_DISTDIR = "usr/portage/distfiles"
	#COMPAT_PKGDIR = "usr/portage/packages"
	#COMPAT_RPMDIR = "usr/portage/rpm"
	#COMPAT_MAIN_REPO = "usr/portage"
    #	If the current installation is still configured to use any of the legacy default /usr/portage locations, 
	#	then patch make.globals and repos.conf inside ${ED} to maintain compatible defaults
lib/portage/_compat_upgrade/meson.build
	# ( system build script, config for installing this package )
lib/portage/_emirrordist/__init__.py	# empty
lib/portage/_emirrordist/main.py
	#	"emirrordist - a fetch tool for mirroring " "of package distfiles"
lib/portage/_emirrordist/Config.py
lib/portage/_emirrordist/ContentDB.py
lib/portage/_emirrordist/DeletionIterator.py
lib/portage/_emirrordist/DeletionTask.py
lib/portage/_emirrordist/FetchIterator.py
lib/portage/_emirrordist/FetchTask.py
lib/portage/_emirrordist/MirrorDistTask.py
lib/portage/_global_updates.py
	#def _global_updates(trees, prev_mtimes, quiet=False, if_mtime_changed=True):
    #	Perform new global updates if they exist in 'profiles/updates/'
    #	subdirectories of all active repositories (PORTDIR + PORTDIR_OVERLAY).
	#def _do_global_updates(trees, prev_mtimes, quiet=False, if_mtime_changed=True):
    #	'update pass'",
    #	'binary update'",
    #	'/var/db update'",
    #	'/var/db move'",
    #	'/var/db SLOT move'",
    #	'binary move'",
    #	'binary SLOT move'",
    #	'update /etc/portage/package.*'",
    #def _world_repo_match(atoma, atomb):
	#   Check whether to perform a world change from atoma to atomb.
lib/portage/_legacy_globals.py
	#portage._initializing_globals = True
	#def _get_legacy_global(name):
	#    ("config_root", "PORTAGE_CONFIGROOT"),
	#    ("target_root", "ROOT"),
	#    ("sysroot", "SYSROOT"),
	#    ("eprefix", "EPREFIX"),
lib/portage/_selinux.py
	#copyfile,getcontext,is_selinux_enabled,mkdir,rename,settype,setexec,setfscreate,symlink
	#class spawn_wrapper:
lib/portage/_sets/__init__.py
	# lots of stuff in this file.
	#class SetConfig:
	#def _create_default_config(self):
    #    Create a default hardcoded set configuration for a portage version that does not support set configuration files.
	# 	 This is only used in the current branch of portage if _ENABLE_SET_CONFIG is False.
    #    Even if it's not used in this branch, keep it here in order to minimize the diff between branches.
	#def load_default_config(settings, trees):
lib/portage/_sets/meson.build
	# ( system build script, config for installing this package )
lib/portage/_sets/base.py
	#class PackageSet:
    #	Set this to operations that are supported by your subclass. While technically there is no difference between "merge" and "unmerge" regarding
    # 	package sets, the latter doesn't make sense for some sets like "system" or "security" and therefore isn't supported by them.
    #	_operations = ["merge"]
    #	description = "generic package set"
	#class EditablePackageSet(PackageSet):
	#class InternalPackageSet(EditablePackageSet):
	#class DummyPackageSet(PackageSet):
lib/portage/_sets/dbapi.py
	#	__all__ = [
	#    "CategorySet",
	#    "ChangedDepsSet",
	#    "DowngradeSet",
	#    "EverythingSet",
	#    "OwnerSet",
	#    "SubslotChangedSet",
	#    "VariableSet",	]
	#_operations = ["merge", "unmerge"]
	#_builderGetRepository, singleBuilder, multiBuilder
	#class EverythingSet(PackageSet):
	#	Package set which contains SLOT atoms to match all installed packages
	#	load()
	#class OwnerSet(PackageSet):
	#	Package set which contains all packages that own one or more files.
	#	mapPathsToAtoms()
	#class VariableSet(EverythingSet):
	#	Package set which contains all packages that match specified values of a specified variable.
	#	_filter()
	#class SubslotChangedSet(PackageSet):
	#   Package set which contains all packages for which the subslot of the highest visible ebuild 
	#	is different than the currently installed version.
	#	load() # bestmatch-visible
	#class DowngradeSet(PackageSet):
	#   Package set which contains all packages for which the highest visible ebuild version
	#	is lower than the currently installed version.
	#	load() # bestmatch-visible
	#class UnavailableSet(EverythingSet):
    #   Package set which contains all installed packages for which there are no visible ebuilds
    #   corresponding to the same $CATEGORY/$PN:$SLOT.
	#	_filter()
	#class UnavailableBinaries(EverythingSet):
    #   Package set which contains all installed packages for which corresponding binary packages
    #   are not available.
	#	_filter()
	#class CategorySet(PackageSet):
	#	Package set containing {visible/all} packages of category
	#class AgeSet(EverythingSet):
	#	older or newer than TIMESTAMP
	#	_aux_keys = ("BUILD_TIME",)
	#class DateSet(EverythingSet):
	#	older or newer than: # options specified: 'package', 'filestamp', 'seconds', 'date'
	#	_aux_keys = ("BUILD_TIME",)
	#class RebuiltBinaries(EverythingSet):
	#	if binaries have been rebuilt since last install
	#	_aux_keys = ("BUILD_TIME",)
	#class ChangedDepsSet(PackageSet):
	#	Package set which contains all installed packages for which the vdb *DEPEND entries are outdated
	#	compared to corresponding portdb entries.
	# get all *DEPEND variables from vdb & portdb and compare them.
lib/portage/_sets/files.py
	#__all__ = [
	#    "StaticFileSet",
	#    "ConfigFileSet",
	#    "WorldSelectedSet",
	#    "WorldSelectedPackagesSet",
	#    "WorldSelectedSetsSet",	]
	#class StaticFileSet(EditablePackageSet):
	#class ConfigFileSet(PackageSet):
	#class WorldSelectedSet(EditablePackageSet):
    #	Set of packages and subsets that were directly installed by the user
	#class WorldSelectedPackagesSet(EditablePackageSet):
	#  	Set of packages that were directly installed by the user
	#class WorldSelectedSetsSet(EditablePackageSet):
	#   Set of sets that were directly installed by the user
lib/portage/_sets/libs.py
	#class LibraryConsumerSet(PackageSet):
	#class LibraryFileConsumerSet(LibraryConsumerSet):
    #	Package set which contains all packages that consume the specified library file(s).
	#class PreservedLibraryConsumerSet(LibraryConsumerSet):
lib/portage/_sets/ProfilePackageSet.py
	#class ProfilePackageSet(PackageSet):
lib/portage/_sets/profiles.py
	#__all__ = ["PackagesSystemSet"]
	#class PackagesSystemSet(PackageSet):
lib/portage/_sets/security.py
	#__all__ = ["SecuritySet", "NewGlsaSet", "NewAffectedSet", "AffectedSet"]
	#class SecuritySet(PackageSet):
	#    description = "package set that includes all packages possibly affected by a GLSA"
lib/portage/_sets/shell.py
	#__all__ = ["CommandOutputSet"]
	#class CommandOutputSet(PackageSet):
	#	This class creates a PackageSet from the output of any shell command. The shell command should produce one atom per line
lib/portage/binpkg.py
	#def get_binpkg_format(binpkg_path, check_file=False, remote=False):
	#	file_ext_format = "xpak"   or 	"gpkg"
lib/portage/binrepo/__init__.py	# empty
lib/portage/binrepo/meson.build
	# ( system build script, config for installing this package )
lib/portage/binrepo/config.py
	#class BinRepoConfig:
    #	__slots__ = (
    #	  "name",
    #  	  "name_fallback",
    #  	  "fetchcommand",
    #  	  "priority",
    #  	  "resumecommand",
    #  	  "sync_uri",
#CACHE
lib/portage/cache/__init__.py	# empty
lib/portage/cache/meson.build
	# ( system build script, config for installing this package )
lib/portage/cache/anydbm.py
lib/portage/cache/cache_errors.py
lib/portage/cache/ebuild_xattr.py
lib/portage/cache/flat_hash.py
lib/portage/cache/fs_template.py
lib/portage/cache/index/IndexStreamIterator.py
lib/portage/cache/index/__init__.py
lib/portage/cache/index/meson.build
	# ( system build script, config for installing this package )
lib/portage/cache/index/pkg_desc_index.py
lib/portage/cache/mappings.py
lib/portage/cache/metadata.py
lib/portage/cache/sql_template.py
lib/portage/cache/sqlite.py
lib/portage/cache/template.py
lib/portage/cache/volatile.py
lib/portage/checksum.py
	# Summary of all available hashes and their implementations,
	# MD5: hashlib
	# SHA1: hashlib
	# SHA256: hashlib
	# SHA512: hashlib
	# RMD160: hashlib, pycrypto, mhash
	# WHIRLPOOL: hashlib, bundled (C), bundled (Python)
	# BLAKE2B (512): hashlib
	# BLAKE2S (512): hashlib
	# SHA3_256: hashlib
	# SHA3_512: hashlib
	#def verify_all(filename, mydict, calc_prelink=0, strict=0):
	#    Verify all checksums against a file.
	#def perform_checksum(filename, hashname="MD5", calc_prelink=0):
	#    Run a specific checksum against a file
	#def perform_multiple_checksums(filename, hashes=["MD5"], calc_prelink=0):
	#    Run a group of checksums against a file.
	#def checksum_str(data, hashname="MD5"):
	#    Run a specific checksum against a byte string.
lib/portage/const.py
	# list of constants/default variables
lib/portage/cvstree.py
	#CVS version control consistency checks (old)
lib/portage/data.py
	# global initialization, user modes, file permissions, priveleges, env vars
lib/portage/dbapi/DummyTree.py
lib/portage/dbapi/IndexedPortdb.py
lib/portage/dbapi/IndexedVardb.py
lib/portage/dbapi/_ContentsCaseSensitivityManager.py
lib/portage/dbapi/_MergeProcess.py
lib/portage/dbapi/_SyncfsProcess.py
lib/portage/dbapi/_VdbMetadataDelta.py
lib/portage/dbapi/__init__.py
	# tons of stuff in here!
lib/portage/dbapi/meson.build
	# ( system build script, config for installing this package )
lib/portage/dbapi/_expand_new_virt.py
lib/portage/dbapi/_similar_name_search.py
lib/portage/dbapi/bintree.py
lib/portage/dbapi/cpv_expand.py
lib/portage/dbapi/dep_expand.py
lib/portage/dbapi/porttree.py
lib/portage/dbapi/vartree.py
lib/portage/dbapi/virtual.py
lib/portage/debug.py
	#def set_trace(on=True):
	#class trace_handler:
lib/portage/dep/__init__.py
	# tons of stuff in here!
lib/portage/dep/meson.build
	# ( system build script, config for installing this package )
lib/portage/dep/_dnf.py
lib/portage/dep/_slot_operator.py
lib/portage/dep/dep_check.py
lib/portage/dep/soname/SonameAtom.py
	#class SonameAtom:
   	#	__slots__ = ("multilib_category", "soname", "_hash_key", "_hash_value")
lib/portage/dep/soname/__init__.py
lib/portage/dep/soname/meson.build
	# ( system build script, config for installing this package )
lib/portage/dep/soname/multilib_category.py
	#def compute_multilib_category(elf_header):
    #	Compute a multilib category from an ELF header.
lib/portage/dep/soname/parse.py
	#def parse_soname_deps(s):
    #	Parse a REQUIRES or PROVIDES dependency string, and raise InvalidData if necessary.
lib/portage/dispatch_conf.py
#### Main dispatch-conf program
	# file-archive, archive-copy, archive-rotate, perform_conf_update_hooks
lib/portage/eapi.py
	# prototypes, attributes and definitions and rules for which EAPI goes to what feature
lib/portage/eclass_cache.py
	#class cache:
    #	Maintains the cache information about eclasses used in ebuild.
#ELOG
lib/portage/elog/__init__.py
	# tons of stuff in here!
lib/portage/elog/meson.build
	# ( system build script, config for installing this package )
lib/portage/elog/filtering.py
	# Output
lib/portage/elog/messages.py
	# logging
#ELOG
lib/portage/elog/mod_custom.py
lib/portage/elog/mod_echo.py
lib/portage/elog/mod_mail.py
lib/portage/elog/mod_mail_summary.py
lib/portage/elog/mod_save.py
lib/portage/elog/mod_save_summary.py
lib/portage/elog/mod_syslog.py
#ELOG
#EMAINT
lib/portage/emaint/__init__.py # empty
	# System health checks and maintenance utilities.
lib/portage/emaint/meson.build
	# ( system build script, config for installing this package )
lib/portage/emaint/defaults.py
	# emaint usage description --check, --fix, --version
lib/portage/emaint/main.py
	#def emaint_main(myargv):
lib/portage/emaint/modules/__init__.py	# empty
	# Plug-in modules for system health checks and maintenance.
lib/portage/emaint/modules/meson.build
	# ( system build script, config for installing this package )
lib/portage/emaint/modules/binhost/__init__.py
lib/portage/emaint/modules/binhost/binhost.py
	#class BinhostHandler:
    #	Generate a metadata index for binary packages
lib/portage/emaint/modules/binhost/meson.build
lib/portage/emaint/modules/config/__init__.py
lib/portage/emaint/modules/config/config.py
lib/portage/emaint/modules/config/meson.build
lib/portage/emaint/modules/logs/__init__.py
lib/portage/emaint/modules/logs/logs.py
lib/portage/emaint/modules/logs/meson.build
lib/portage/emaint/modules/merges/__init__.py
lib/portage/emaint/modules/merges/merges.py
lib/portage/emaint/modules/merges/meson.build
lib/portage/emaint/modules/move/__init__.py
lib/portage/emaint/modules/move/meson.build
lib/portage/emaint/modules/move/move.py
lib/portage/emaint/modules/resume/__init__.py
lib/portage/emaint/modules/resume/meson.build
lib/portage/emaint/modules/resume/resume.py
lib/portage/emaint/modules/sync/__init__.py
lib/portage/emaint/modules/sync/meson.build
lib/portage/emaint/modules/sync/sync.py
lib/portage/emaint/modules/world/__init__.py
lib/portage/emaint/modules/world/meson.build
lib/portage/emaint/modules/world/world.py
#EMAINT
#ENV
lib/portage/env/__init__.py
lib/portage/env/meson.build
	# ( system build script, config for installing this package )
lib/portage/env/config.py
    #__all__ = [
    #    "ConfigLoaderKlass",
    #    "GenericFile",
    #    "PackageKeywordsFile",
    #    "PackageUseFile",
    #    "PackageMaskFile",
    #    "PortageModulesFile",	]
	#class ConfigLoaderKlass(UserDict):
	#class GenericFile(UserDict):
	#class PackageKeywordsFile(ConfigLoaderKlass):
	#class PackageUseFile(ConfigLoaderKlass):
	#class PackageMaskFile(ConfigLoaderKlass):
	#class PortageModulesFile(ConfigLoaderKlass):
lib/portage/env/loaders.py
	#def RecursiveFileLoader(filename):
	#class DataLoader:
	#class EnvLoader(DataLoader):
	#class TestTextLoader(DataLoader):
	#class FileLoader(DataLoader):
	#class ItemFileLoader(FileLoader):
	#class KeyListFileLoader(FileLoader):
	#class KeyValuePairFileLoader(FileLoader):
lib/portage/env/validators.py
	#def PackagesFileValidator(atom):
    #	This function mutates atoms that begin with - or *
	#	It then checks to see if that atom is valid, and if so returns True, else it returns False.
lib/portage/exception.py
	#class PortageException(Exception):
	#class PortageKeyError(KeyError, PortageException):
	#class CorruptionError(PortageException):
	#class InvalidDependString(PortageException):
	#class InvalidVersionString(PortageException):
	#class SecurityViolation(PortageException):
	#class IncorrectParameter(PortageException):
	#class MissingParameter(PortageException):
	#class ParseError(PortageException):
	#class InvalidData(PortageException):
	#class InvalidDataType(PortageException):
	#class InvalidLocation(PortageException):
	#class FileNotFound(InvalidLocation):
	#class DirectoryNotFound(InvalidLocation):
	#class IsADirectory(PortageException):
	#class OperationNotPermitted(PortageException):
	#class OperationNotSupported(PortageException):
	#class PermissionDenied(PortageException):
	#class TryAgain(PortageException):
	#class TimeoutException(PortageException):
	#class AlarmSignal(TimeoutException):
	#class ReadOnlyFileSystem(PortageException):
	#class CommandNotFound(PortageException):
	#class AmbiguousPackageName(ValueError, PortageException):
	#class PortagePackageException(PortageException):
	#class PackageNotFound(PortagePackageException):
	#class PackageSetNotFound(PortagePackageException):
	#class InvalidPackageName(PortagePackageException):
	#class InvalidBinaryPackageFormat(PortagePackageException):
	#class InvalidCompressionMethod(PortagePackageException):
	#class CompressorNotFound(PortagePackageException):
	#class CompressorOperationFailed(PortagePackageException):
	#class InvalidAtom(PortagePackageException):
	#class UnsupportedAPIException(PortagePackageException):
	#class SignatureException(PortageException):
	#class DigestException(SignatureException):
	#class GPGException(SignatureException):
	#class MissingSignature(SignatureException):
	#class InvalidSignature(SignatureException):
	#class UntrustedSignature(SignatureException):
lib/portage/getbinpkg.py
	#def make_metadata_dict(data):
	#class ParseLinks(html_parser_HTMLParser):
	#def create_conn(baseurl, conn=None):
	#def make_ftp_request(conn, address, rest=None, dest=None):
	#def make_http_request(conn, address, _params={}, headers={}, dest=None):
	#def match_in_array(array, prefix="", suffix="", match_both=1, allow_overlap=0):
	#def dir_get_list(baseurl, conn=None):
	#def file_get_metadata(baseurl, conn=None, chunk_size=3000):
	#def file_get(. . .)
	#def file_get_lib(baseurl, dest, conn=None):
	#def dir_get_metadata(. . .)
	#def _cmp_cpv(d1, d2):
	#class PackageIndex:
lib/portage/glsa.py
	#def get_applied_glsas(settings):
	#	Return a list of applied or injected GLSA IDs
	#def wrap(text, width, caption=""):
	#	Wraps the given text at column I{width}, optionally indenting it
	#def get_glsa_list(myconfig):
	#	 Returns a list of all available GLSAs in the given repository by comparing 
	#	 the filelist there with the pattern described in the config.
	#def getListElements(listnode):
	#	xml - Get all <li> elements for a given <ol> or <ul> node.
	#def getText(node, format, textfd=None):
	#	Main XML node parser function
	#def getMultiTagsText(rootnode, tagname, format):
	#	Returns a list with the text of all subnodes of type I{tagname} under I{rootnode} 
	#def makeAtom(pkgname, versionNode):
	#	 creates - a (syntactical) valid portage atom -
	#	 from the given package name and information in the I{versionNode}
	#def makeVersion(versionNode):
	#	creates - a version string (format <op><version>) -
	#	from the information in the I{versionNode}
	#def match(atom, dbapi, match_type="default"):
	#    wrapper that calls revisionMatch() or portage.dbapi.dbapi.match() depending on the given atom.
	#def revisionMatch(revisionAtom, dbapi, match_type="default"):
	#	handler for the special >~, >=~, <=~ and <~ atoms that are supposed to behave
    #	as > and < except that they are limited to the same version, the range only applies to the revision part.
	#def getMinUpgrade(vulnerableList, unaffectedList, portdbapi, vardbapi, minimize=True):
	#    Checks if the system-state is matching an atom in I{vulnerableList} and returns string describing
	#    the lowest version for the package that matches an atom in I{unaffectedList} and is greater than the currently installed version
	#def format_date(datestr):
	#	    Takes a date (announced, revised) date from a GLSA and formats it as readable text (i.e. "January 1, 2008").
	#class GlsaTypeException(Exception):
	#class GlsaFormatException(Exception):
	#class GlsaArgumentException(Exception):
	#	# simple Exception classes to catch specific errors
	#class Glsa:
	#	# GLSA xml data wrapper class
	#	    This class is a wrapper for the XML data and provides methods to access and display the contained data.
	#***# main function with submethods
lib/portage/gpg.py
	#class GPG:
    #	Unlock GPG, must call dircetly from main program for get correct TTY
    #    self.digest_algo = self.settings.get("BINPKG_GPG_SIGNING_DIGEST")
    #    self.signing_gpg_home = self.settings.get("BINPKG_GPG_SIGNING_GPG_HOME")
    #    self.signing_gpg_key = self.settings.get("BINPKG_GPG_SIGNING_KEY")
	#    def gpg_keepalive(self):
    #	    Call GPG unlock command every 5 mins to avoid the passphrase expired.
lib/portage/gpkg.py
	#class tar_stream_writer:
	#    One-pass helper function that return a file-like object for create a file inside of a tar container.
	#    This helper allowed streaming add a new file to tar without prior knows the file size.
	#    With optional call and pipe data through external program, the helper can transparently save compressed data.
	#    With optional checksum helper, this helper can create corresponding checksum and GPG signature.
	#class tar_stream_reader:
	#    helper function that return a file-like object for read a file inside of a tar container.
	#    This helper allowed transparently streaming read a compressed file in tar.
	#    With optional call and pipe compressed data through external  program, and return the uncompressed data.
	#class checksum_helper:
	#    Do checksum generation and GPG Signature generation and verification
	#class tar_safe_extract:
	#    A safer version of tar extractall that doing sanity check. Note that this does not solve all security problems.
	#class gpkg:
    #	Gentoo binary package - https://www.gentoo.org/glep/glep-0078.html
	#	 gpkg class handle all gpkg operations for one package.  basename is the package basename.
	#	 def unpack_metadata(self, dest_dir=None):
	#        Unpack metadata to dest_dir.
	#    def get_metadata(self, want=None):
	#        get package metadata. (local file)
	#    def get_metadata_url(self, url, want=None):
	#        Return the requested metadata from url gpkg. (remote)
    #    def compress(self, root_dir, metadata, clean=False):
    #        Use initialized configuation create new gpkg file from root_dir. Will overwrite any exists file.
	#    def decompress(self, decompress_dir):
	#        decompress current gpkg to decompress_dir
	#    def update_metadata(self, metadata, new_basename=None):
	#        Update metadata in the gpkg file.
	#    def update_signature(self, keep_current_signature=False):
	#        Add / update signature in the gpkg file.
	#        if keep_current_signature is True, keep the current signature, otherwise, re-signing it.
	#    def _quickpkg(self, contents, metadata, root_dir, protect=None):
	#        Similar to compress, but for quickpkg.
	#        Will compress the given files to image with root, ignoring all other files.
	#    def _record_checksum(self, checksum_info, tarinfo):
	#        Record checksum result for the given file.
	#        Replace old checksum if already exists.
	#    def _add_manifest(self, container):
	#        Add Manifest to the container based on current checksums.
	#        Creare GPG signatue if needed.
	#	 def _load_manifest(self, manifest_string):
	#		 Check, load, and return manifest in a list by files
	#    def _add_signature(self, checksum_info, tarinfo, container, manifest=True):
	#        Add GPG signature for the given tarinfo file.
	#        manifest: add to manifest
	#    def _verify_binpkg(self, metadata_only=False):
	#        Verify current GPKG file.
	#    def _get_binary_cmd(self, compression, mode):
	#        get command list from portage and try match compressor
	#	 + more internal tar file manager_commands
lib/portage/installation.py
	#Enum("InstallationType", [
	#        "SOURCE",  # Portage is not installed, but running from its source tree.
	#        "MODULE",  # Portage is installed solely as a Python module.
	#        "SYSTEM",  # Portage is fully installed to the system, possibly prefixed. ], )
lib/portage/localization.py
	#def _(mystr):
	#    Always returns unicode
	#def localization_example():
	#    Dict references allow translators to rearrange word order.
	#def localized_size(num_bytes):
	#    Return pretty localized size string for num_bytes size
lib/portage/locks.py
	#__all__ = [
	#    "lockdir",
	#    "unlockdir",
	#    "lockfile",
	#    "unlockfile",
	#    "hardlock_name",
	#    "hardlink_is_mine",
	#    "hardlink_lockfile",
	#    "unhardlink_lockfile",
	#    "hardlock_cleanup",	]
lib/portage/mail.py
lib/portage/manifest.py
	#class FileNotInManifestException(PortageException):
	#def manifest2AuxfileFilter(filename):
	#def manifest2MiscfileFilter(filename):
	#def guessManifestFileType(filename):
	#def guessThinManifestFileType(filename):
	#def parseManifest2(line):
	#class ManifestEntry:
	#class Manifest2Entry(ManifestEntry):
	#class Manifest:
	#	Create new Manifest instance for package in pkgdir.
	#	+ all kinds of manifest manager functions
lib/portage/meson.build
	# ( system build script, config for installing this package )
lib/portage/metadata.py
	# action metadata
	#def action_metadata(settings, portdb, myopts, porttrees=None):
	#	">>> Updating Portage cache\n"
lib/portage/module.py
	#class InvalidModuleName(PortageException):
	#	An invalid or unknown module name
	#class ModuleVersionError(PortageException):
	#	An incompatible module version
	#class Module:
	#	Class to define and hold our plug-in module
	#class Modules:
	#	Dynamic modules system for loading and retrieving any of the installed emaint modules and/or provided class's
lib/portage/news.py
	#class NewsManager:
    #	This object manages GLEP 42 style news items.  It will cache news items	that have previously shown up 
	#	and notify users when there are relevant news items that apply to their packages that the user has not previously read.
lib/portage/output.py
	# xterms, titles, colorize, color.map, terminal, tty, compatibility, console style, EOutput, ProgressBar, TermProgressBar 
#PACKAGE
lib/portage/package/__init__.py	# empty
lib/portage/package/ebuild/__init__.py	# empty
lib/portage/package/meson.build
	# ( system build script, config for installing this package )
lib/portage/package/ebuild/_config/KeywordsManager.py
lib/portage/package/ebuild/_config/LicenseManager.py
lib/portage/package/ebuild/_config/LocationsManager.py
lib/portage/package/ebuild/_config/MaskManager.py
lib/portage/package/ebuild/_config/UseManager.py
lib/portage/package/ebuild/_config/VirtualsManager.py
lib/portage/package/ebuild/_config/__init__.py
lib/portage/package/ebuild/_config/meson.build
	# ( system build script, config for installing this package )
lib/portage/package/ebuild/_config/env_var_validation.py
lib/portage/package/ebuild/_config/features_set.py
lib/portage/package/ebuild/_config/helper.py
lib/portage/package/ebuild/_config/special_env_vars.py
lib/portage/package/ebuild/_ipc/ExitCommand.py
lib/portage/package/ebuild/_ipc/IpcCommand.py
lib/portage/package/ebuild/_ipc/QueryCommand.py
lib/portage/package/ebuild/_ipc/__init__.py
lib/portage/package/ebuild/_ipc/meson.build
	# ( system build script, config for installing this package )
lib/portage/package/ebuild/_metadata_invalid.py
lib/portage/package/ebuild/_parallel_manifest/ManifestProcess.py
lib/portage/package/ebuild/_parallel_manifest/ManifestScheduler.py
lib/portage/package/ebuild/_parallel_manifest/ManifestTask.py
lib/portage/package/ebuild/_parallel_manifest/__init__.py
lib/portage/package/ebuild/_parallel_manifest/meson.build
	# ( system build script, config for installing this package )
lib/portage/package/ebuild/_spawn_nofetch.py
lib/portage/package/ebuild/config.py
lib/portage/package/ebuild/deprecated_profile_check.py
lib/portage/package/ebuild/digestcheck.py
lib/portage/package/ebuild/digestgen.py
lib/portage/package/ebuild/doebuild.py
lib/portage/package/ebuild/fetch.py
lib/portage/package/ebuild/getmaskingreason.py
lib/portage/package/ebuild/getmaskingstatus.py
lib/portage/package/ebuild/meson.build
	# ( system build script, config for installing this package )
lib/portage/package/ebuild/prepare_build_dirs.py
lib/portage/package/ebuild/profile_iuse.py
#PACKAGE
lib/portage/process.py
	#sandbox_capable = os.path.isfile(SANDBOX_BINARY) and os.access(SANDBOX_BINARY, os.X_OK)
	#fakeroot_capable = os.path.isfile(FAKEROOT_BINARY) and os.access(
	#def sanitize_fds():
	#def spawn_bash(mycommand, debug=False, opt_name=None, **keywords):
	#def spawn_sandbox(mycommand, opt_name=None, **keywords):
	#def spawn_fakeroot(mycommand, fakeroot_state=None, opt_name=None, **keywords):
	#def atexit_register(func, *args, **kargs):
	#def run_exitfuncs():
	#	atexit.register(run_exitfuncs)
	#class _dummy_list(list):
	#	spawned_pids = _dummy_list()
	#def cleanup():
	#class EnvStats:
	#	def calc_env_stats(env) -> EnvStats:
	#def spawn( . . . )
	#def _has_ipv6():
	#def _configure_loopback_interface():
	#def _exec( . . . )
	#class _unshare_validator:
	#def _setup_pipes(fd_pipes, close_fds=True, inheritable=None):
	#def find_binary(binary):
lib/portage/progress.py
	#class ProgressHandler:
	#class ProgressBar(ProgressHandler):
    #	Class to set up and return a Progress Bar
lib/portage/proxy/__init__.py
lib/portage/proxy/meson.build
	# ( system build script, config for installing this package )
lib/portage/proxy/lazyimport.py
lib/portage/proxy/objectproxy.py
#PROXY
#REPOSITORY
lib/portage/repository/__init__.py
lib/portage/repository/meson.build
	# ( system build script, config for installing this package )
lib/portage/repository/config.py
lib/portage/repository/storage/__init__.py
lib/portage/repository/storage/meson.build
	# ( system build script, config for installing this package )
lib/portage/repository/storage/hardlink_quarantine.py
lib/portage/repository/storage/hardlink_rcu.py
lib/portage/repository/storage/inplace.py
lib/portage/repository/storage/interface.py
#REPOSITORY
#SYNC
lib/portage/sync/__init__.py
	# this fill is full of huge stuff
lib/portage/sync/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/config_checks.py
lib/portage/sync/controller.py
lib/portage/sync/getaddrinfo_validate.py
lib/portage/sync/modules/__init__.py # empty 
lib/portage/sync/modules/cvs/__init__.py
	# module spec CVS init
lib/portage/sync/modules/cvs/cvs.py
lib/portage/sync/modules/cvs/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/modules/git/__init__.py
lib/portage/sync/modules/git/git.py
lib/portage/sync/modules/git/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/modules/mercurial/__init__.py
lib/portage/sync/modules/mercurial/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/modules/mercurial/mercurial.py
lib/portage/sync/modules/meson.build
lib/portage/sync/modules/rsync/__init__.py
lib/portage/sync/modules/rsync/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/modules/rsync/rsync.py
lib/portage/sync/modules/svn/__init__.py
lib/portage/sync/modules/svn/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/modules/svn/svn.py
lib/portage/sync/modules/webrsync/__init__.py
lib/portage/sync/modules/webrsync/meson.build
	# ( system build script, config for installing this package )
lib/portage/sync/modules/webrsync/webrsync.py
lib/portage/sync/old_tree_timestamp.py
lib/portage/sync/syncbase.py
#SYNC
#UTIL
lib/portage/util/ExtractKernelVersion.py
lib/portage/util/SlotObject.py
lib/portage/util/__init__.py
lib/portage/util/_async/AsyncFunction.py
lib/portage/util/_async/AsyncScheduler.py
lib/portage/util/_async/AsyncTaskFuture.py
lib/portage/util/_async/BuildLogger.py
lib/portage/util/_async/FileCopier.py
lib/portage/util/_async/FileDigester.py
lib/portage/util/_async/ForkProcess.py
lib/portage/util/_async/PipeLogger.py
lib/portage/util/_async/PipeReaderBlockingIO.py
lib/portage/util/_async/PopenProcess.py
lib/portage/util/_async/SchedulerInterface.py
lib/portage/util/_async/TaskScheduler.py
lib/portage/util/_async/__init__.py
lib/portage/util/_async/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/_async/run_main_scheduler.py
lib/portage/util/_compare_files.py
lib/portage/util/_ctypes.py
lib/portage/util/_desktop_entry.py
lib/portage/util/_dyn_libs/LinkageMapELF.py
lib/portage/util/_dyn_libs/NeededEntry.py
lib/portage/util/_dyn_libs/PreservedLibsRegistry.py
lib/portage/util/_dyn_libs/__init__.py
lib/portage/util/_dyn_libs/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/_dyn_libs/display_preserved_libs.py
lib/portage/util/_dyn_libs/dyn_libs.py
lib/portage/util/_dyn_libs/soname_deps.py
lib/portage/util/_dyn_libs/soname_deps_qa.py
lib/portage/util/_eventloop/__init__.py
lib/portage/util/_eventloop/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/_eventloop/asyncio_event_loop.py
lib/portage/util/_eventloop/global_event_loop.py
lib/portage/util/_get_vm_info.py
lib/portage/util/_info_files.py
lib/portage/util/_path.py
lib/portage/util/_pty.py
lib/portage/util/_urlopen.py
lib/portage/util/_xattr.py
lib/portage/util/backoff.py
lib/portage/util/bin_entry_point.py
lib/portage/util/changelog.py
lib/portage/util/compression_probe.py
lib/portage/util/configparser.py
lib/portage/util/cpuinfo.py
lib/portage/util/digraph.py
lib/portage/util/elf/__init__.py
lib/portage/util/elf/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/elf/constants.py
lib/portage/util/elf/header.py
lib/portage/util/endian/__init__.py
lib/portage/util/endian/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/endian/decode.py
lib/portage/util/env_update.py
lib/portage/util/file_copy/__init__.py
lib/portage/util/file_copy/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/formatter.py
lib/portage/util/futures/__init__.py
lib/portage/util/futures/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/futures/_asyncio/__init__.py
lib/portage/util/futures/_asyncio/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/futures/_asyncio/streams.py
lib/portage/util/futures/_sync_decorator.py
lib/portage/util/futures/compat_coroutine.py
lib/portage/util/futures/executor/__init__.py
lib/portage/util/futures/executor/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/futures/executor/fork.py
lib/portage/util/futures/extendedfutures.py
lib/portage/util/futures/futures.py
lib/portage/util/futures/iter_completed.py
lib/portage/util/futures/retry.py
lib/portage/util/futures/unix_events.py
lib/portage/util/hooks.py
lib/portage/util/install_mask.py
lib/portage/util/iterators/MultiIterGroupBy.py
lib/portage/util/iterators/__init__.py
lib/portage/util/iterators/meson.build
	# ( system build script, config for installing this package )
lib/portage/util/lafilefixer.py
lib/portage/util/listdir.py
lib/portage/util/locale.py
lib/portage/util/meson.build
lib/portage/util/movefile.py
lib/portage/util/mtimedb.py
lib/portage/util/netlink.py
lib/portage/util/path.py
lib/portage/util/shelve.py
lib/portage/util/socks5.py
lib/portage/util/whirlpool.py
lib/portage/util/writeable_check.py
#UTIL
lib/portage/xml/__init__.py	# empty
lib/portage/xml/meson.build
	# ( system build script, config for installing this package )
lib/portage/xml/metadata.py
	#XML metadata
	#	_all__ = ("MetaDataXML", "parse_metadata_use")
#XML
#continue with lib/
lib/portage/update.py
	#ignored_dbentries = ("CONTENTS", "environment.bz2")
	#def update_dbentry(update_cmd, mycontent, eapi=None, parent=None):
	#***# Main vdb update function
	#def update_dbentries(update_iter, mydata, eapi=None, parent=None):
	#	 Performs update commands and returns a  dict containing only the updated items.
	#def fixdbentries(update_iter, dbdir, eapi=None, parent=None):
	#    Performs update commands which result in search and replace operations for each of the files in dbdir (excluding $ignored_dbentries)
	#def grab_updates(updpath, prev_mtimes=None):
	#	 Returns all the updates from the given directory as a sorted list of tuples,
	#	 each containing (file_path, statobj, content)
	#def parse_updates(mycontent):
	#	 Valid updates are returned as a list of split update commands.
	#def update_config_files( . . .)
	#	 Perform global updates on /etc/portage/package.*, /etc/portage/profile/package.*,
	#    /etc/portage/profile/packages and /etc/portage/sets.
	#def dep_transform(mydep, oldkey, newkey):
lib/portage/versions.py
	#PMS spec
	#	 version compare regexes, pkg cat, compare, split, best
lib/portage/xpak.py
	#XPAK
	# create tbz2 & xpak binary packages, files & metadata

#SRC
src/meson.build
	# ( system build script, config for installing this package )
	# subdir('portage'), subdir('_emerge')
# C ports of crucial util functions: 
src/portage_util__whirlpool.c
	#Whirlpool
	#	self contained Whirlpool crypto function written in C
src/portage_util_file_copy_reflink_linux.c
	#reflink_linux
	#	"Module for reflink_linux copy operations", provides file copy
	# "file_copy"
	#	 "Copy between two file descriptors with reflink and sparse file support."
	# _reflink_linux_file_copy
src/portage_util_libc.c
	#libc
	#	Module for converting case using the system locale", provides toupper/tolower
	# toupper
	#	"Convert to upper case using system locale."
	# tolower
	#	"Convert to lower case using system locale."
