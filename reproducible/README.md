# Republished from:
# https://gist.github.com/OstCollector/6397cb05ad47e3602bf2adacf571c540
#  @ OstCollector - cloned June-19-2023 @ gentoo
## documented @ genr8 github now so it doesnt get lost.

# Some attempts to make Gentoo Linux Reproducible


## Motivation

Reproducible build is generally good. [[citation needed]]
Now some distributions, including
[Debian](https://wiki.debian.org/ReproducibleBuilds),
[Fedora](https://fedoraproject.org/wiki/Reproducible_Builds),
[ArchLinux](https://wiki.archlinux.org/title/Reproducible_builds),
[OpenSUSE](https://en.opensuse.org/openSUSE:Reproducible_Builds),
[NetBSD](https://blog.netbsd.org/tnf/entry/netbsd_fully_reproducible_builds),
[NixOS](https://reproducible.nixos.org/),
are making effort to or even already achieved reproducible builds.

## Current state of Gentoo Linux

There is no known effort from Gentoo community.
Someone asked about this feature
[[1]](https://archives.gentoo.org/gentoo-dev/message/6c2d29c67f6fb76fc7bd7d57c7d5fc9f),
but seems developers are not interested.

## What I have done?

I only focus on Gentoo Linux at the moment, so Gentoo Prefix and
Gentoo/FreeBSD are not tested (actually GNU coreutils are required). Now
I can use catalyst to rebuild whole stage3 with most files keeps
consist cross builds within a fixed kernel. Still, some files can not be
reproduced, which are listed as follows:

- ebuild has explictly written timestamp into the file
    - `/etc/ca-certificates` (app-misc/ca-certificates-20230311.3.89.1) 

- files generated by portage during installation
    * System-wide
        - `/var/cache/edb/mtimedb`
        - `/var/cache/edb/vdb_blockers.pickle`
        - `/var/cache/edb/vdb_metadata.pickle`
        - `/var/cache/edb/vdb_metadata_delta.json`
    * Per-packet, located at `/var/db/pkg/<category>/<P>`
        - `./BINPKGMD5`
        - `./BUILD_TIME`
        - `./CONTENTS`
        - `./environment.bz2` (for some packages only)

- files generated by other apps during installation
    - `/var/cache/ldconfig/aux-cache`

The stage tarball as well as binpkg can not be reproduced now. Since such
files need to store timestamp of the files.

Current work is experimental only. The work should not be used in
production environments.

## What is the penalty?
Now I use mtime of ebuild as an input, which may cause binaries
identical to others, which may make attack Gentoo nodes easier.

Now when Python loads a .pyc file, Python will also compute hash of
source file and check if matches the .pyc file. So the loading process
will be slowed down.

## How did I make it?

To archive reproducible build, it is necessary to modify the build
system a bit, so the factors that make builds different can be removed. 
I will show the factors I have found and how to mitigate below.

Assuming the files for mitigation are placed in `${PORTAGE_CONFIG}`.

### Timestamps in static library

Though it is not recommanded to use static libraries in \*nix world,
Gentoo still builds some static libs for several low-level packages,
including glibc, tcl and libcap, when using default config.

However, .a files contains timestamp of the original object files, which
causes .a files differ cross builds. Luckily, binutils, which is
responsible to create .a files contains a configure-time flag
`--enable-deterministic-archives`. When binutils is configured with this
flag, it can generate .a files with zero timestamps, so the .a files are
reproducible. Gentoo maintainer for binutils has added but commentted
out this option. I added this config option into /etc/portage/env as
follows:

```
# ${PORTAGE_CONFIG}/env/binutils-deterministic
catalyst-portage-override/env/binutils-deterministic

# ${PORTAGE_CONFIG}/package.env/binutils
sys-devel/binutils binutils-deterministic
```

### The use of `SOURCE_DATE_EPOCH`

C/C++ has `__DATE__` and `__TIME__` macro which is expanded into
the date and time when preprocessor is invoked.

Also, Python inject the time of the source file into .pyc files.
The mtime is used to check if the original source file is modified.

These timestamps makes reproducible build impossible.

[reproducible-build.org]() has purposed to use `SOURCE_DATE_EPOCH` to got
rid of such problems. GCC and LLVM have taken this envariable into
account [[2]](https://gcc.gnu.org/onlinedocs/cpp/Environment-Variables.html)
[[3]](https://releases.llvm.org/16.0.0/tools/clang/docs/ReleaseNotes.html#non-comprehensive-list-of-changes-in-this-release).

On the other hand, when python build .pyc with `SOURCE_DATE_EPOCH` set to
a valid timestamp, it will use hash rather than mtime of file to check
if the .pyc is still valid.

Note: This bahavior will cause performance degrade, since it is much
faster to check if the mtime is still correct, but for (especially
large) source files, Python interepreter reads the source file and
compute its hash. Fedora Linux are using a different technique, in which
they still use mtime, but make the timestamp of all source files at
`SOURCE_DATE_EPOCH` [[4]](https://fedoraproject.org/wiki/Changes/ReproducibleBuildsClampMtimes#Python_bytecode).
I have no time nor effort into this.

In addition, Python has randomized order for set/map/etc. the order can
be controlled by `PYTHONHASHSEED`.

I use following patch to inject `SOURCE_DATE_EPOCH` with mtime of the
mtime of the ebuild file into the building process. The patch also sets
`PYTHONHASHSEED` with `SOURCE_DATE_EPOCH`.

```
# ${PORTAGE_CONFIG}/patches/sys-apps/portage/source-time-epoch.patch

diff -aurN portage-3.0.44.orig/lib/portage/package/ebuild/_config/special_env_vars.py portage-3.0.44/lib/portage/package/ebuild/_config/special_env_vars.py
--- portage-3.0.44.orig/lib/portage/package/ebuild/_config/special_env_vars.py  2023-01-15 22:11:19.000000000 -0000
+++ portage-3.0.44/lib/portage/package/ebuild/_config/special_env_vars.py       2023-06-06 23:16:46.706213851 -0000
@@ -187,6 +187,8 @@
         "ROOT",
         "ROOTPATH",
         "SANDBOX_LOG",
+        "SOURCE_DATE_EPOCH",
+        "PYTHONHASHSEED",
         "SYSROOT",
         "T",
         "TMP",
diff -aurN portage-3.0.44.orig/lib/portage/package/ebuild/doebuild.py portage-3.0.44/lib/portage/package/ebuild/doebuild.py
--- portage-3.0.44.orig/lib/portage/package/ebuild/doebuild.py  2023-01-15 22:11:19.000000000 -0000
+++ portage-3.0.44/lib/portage/package/ebuild/doebuild.py       2023-06-06 17:13:08.494561529 -0000
@@ -346,6 +346,8 @@
     mysettings = settings
     mydbapi = db
     ebuild_path = os.path.abspath(myebuild)
+    source_date_epoch = os.stat(ebuild_path).st_mtime_ns
+    source_date_epoch = source_date_epoch // 1000 ** 3
     pkg_dir = os.path.dirname(ebuild_path)
     mytree = os.path.dirname(os.path.dirname(pkg_dir))
     mypv = os.path.basename(ebuild_path)[:-7]
@@ -420,6 +422,8 @@
         mysettings["PORTAGE_DEBUG"] = "1"

     mysettings["EBUILD"] = ebuild_path
+    mysettings["SOURCE_DATE_EPOCH"] = str(source_date_epoch)
+    mysettings["PYTHONHASHSEED"] = str(source_date_epoch)
     mysettings["O"] = pkg_dir
     mysettings.configdict["pkg"]["CATEGORY"] = cat
     mysettings["PF"] = mypv
```

### Per-package work

#### Perl

Perl has `perlbug` and `perlthank`, which are generated at build time
with timestamp embedded. Following patch can be used to git rid of it.

```
patches/dev-lang/perl/reproducible.patch

diff -aurN perl-5.36.0.orig/Configure perl-5.36.0/Configure
--- perl-5.36.0.orig/Configure  2023-06-11 12:08:49.131553625 -0000
+++ perl-5.36.0/Configure       2023-06-11 12:11:24.282596273 -0000
@@ -3867,7 +3867,11 @@
 . ./posthint.sh

 : who configured the system
-cf_time=`LC_ALL=C; LANGUAGE=C; export LC_ALL; export LANGUAGE; $date 2>&1`
+if $test -n "${SOURCE_DATE_EPOCH}" ;then
+       cf_time=`LC_ALL=C; LANGUAGE=C; export LC_ALL; export LANGUAGE; $date --date="@${SOURCE_DATE_EPOCH}" 2>&1`
+else
+       cf_time=`LC_ALL=C; LANGUAGE=C; export LC_ALL; export LANGUAGE; $date 2>&1`
+fi
 case "$cf_by" in
 "")
        cf_by=`(logname) 2>/dev/null`
diff -aurN perl-5.36.0.orig/utils/perlbug.PL perl-5.36.0/utils/perlbug.PL
--- perl-5.36.0.orig/utils/perlbug.PL   2020-12-28 16:57:44.000000000 -0000
+++ perl-5.36.0/utils/perlbug.PL        2023-06-11 12:11:55.788746681 -0000
@@ -31,6 +31,9 @@
     or die "Can't find patchlevel.h: $!";

 my $patchlevel_date = (stat _)[9];
+if ( exists $ENV{'SOURCE_DATE_EPOCH'} && defined $ENV{'SOURCE_DATE_EPOCH'} ) {
+    $patchlevel_date = $ENV{'SOURCE_DATE_EPOCH'};
+}

 # TO DO (perhaps): store/embed $Config::config_sh into perlbug. When perlbug is
 # used, compare $Config::config_sh with the stored version. If they differ then
```

### Metadata from portage itself
Portage has various metadata exported to `/var/db/pkg/<category>/<P>`,
I have identified some of them.

#### `environment.bz2` from bash
Bash has several environment variables, like `${RANDOM} ${SRANDOM}
${EPOCHREALTIME} ${EPOCHSECONDS}`. These variables would be exported to
`environment.bz2`. Use following patch to drop them.

```
# ${PORTAGE_CONFIG}/patches/sys-apps/portage/trim-bash-var.patch


diff -aurN portage-3.0.44.orig/bin/save-ebuild-env.sh portage-3.0.44/bin/save-ebuild-env.sh
--- portage-3.0.44.orig/bin/save-ebuild-env.sh  2023-01-15 22:11:19.000000000 -0000
+++ portage-3.0.44/bin/save-ebuild-env.sh       2023-06-10 04:53:29.835669374 -0000
@@ -115,6 +115,9 @@
        # user config variables
        unset DOC_SYMLINKS_DIR INSTALL_MASK PKG_INSTALL_MASK

+       # Always changing variables, causing build nonreproducible
+       unset EPOCHREALTIME EPOCHSECONDS RANDOM SRANDOM
+
        declare -p
        declare -fp
        if [[ ${BASH_VERSINFO[0]} == 3 ]]; then
```

#### FEATURES variable
Under certain circumstances, file FEATURES and variable FEATURES in
`environment.bz2` are not ordered deterministically, even though
`PYTHONHASHSEED` is set.

Following patch can make FEATURES ordered:

```
# ${PORTAGE_CONFIG}/patches/sys-apps/portage/predictable-features-with-test.patch

diff -aurN portage-3.0.44.orig/lib/portage/package/ebuild/config.py portage-3.0.44/lib/portage/package/ebuild/config.py
--- portage-3.0.44.orig/lib/portage/package/ebuild/config.py    2023-01-15 22:11:19.000000000 -0000
+++ portage-3.0.44/lib/portage/package/ebuild/config.py 2023-06-11 23:16:01.171073495 -0000
@@ -2206,7 +2206,7 @@
                 # "test" is in IUSE and USE=test is masked, so execution
                 # of src_test() probably is not reliable. Therefore,
                 # temporarily disable FEATURES=test just for this package.
-                self["FEATURES"] = " ".join(x for x in self.features if x != "test")
+                self["FEATURES"] = " ".join(x for x in sorted(self.features) if x != "test")

         # Allow _* flags from USE_EXPAND wildcards to pass through here.
         use.difference_update(
```

## Unknown or failed

### Time of installed files

I tried to use Following patch to change the mtime of install files to
`SOURCE_DATE_EPOCH`, but it causes portage itself is broken.

```
diff -aurN portage-3.0.44.orig/bin/phase-functions.sh portage-3.0.44/bin/phase-functions.sh
--- portage-3.0.44.orig/bin/phase-functions.sh  2023-01-15 22:11:19.000000000 -0000
+++ portage-3.0.44/bin/phase-functions.sh       2023-06-10 10:17:05.222121457 -0000
@@ -618,6 +618,9 @@
        __vecho
        __ebuild_phase post_src_install

+       # Not preapred for non-Linux install
+       find "${D}" -exec touch -d "@${SOURCE_DATE_EPOCH}" {} \;
+
        # record build & installed size in build log
        if type -P du &>/dev/null; then
                local nsz=( $(du -ks "${WORKDIR}") )
```

I noticed that the patched portage also installs
`/usr/lib/python-exec/python-exec2` when installing itself. The file
should be installed by `dev-lang/python-exec`. So a file collision
occurs.

### `PYTHON_TARGETS`
I noticed variable `PYTHON_TARGETS` listed in `environment.bz2` may
differ between builds. Only `dev-python/python-exec` is the only
affected package observed. I haven't identified the reason yet.

### Kernel related

It seems some packages need to test kernel features and versions before
actual emerging. I am unsure if the build is reproducible between
different kernels.

# Republished from:
# https://gist.github.com/OstCollector/6397cb05ad47e3602bf2adacf571c540
# @ OstCollector - cloned June-19-2023 @ gentoo
## documented @ genr8 github now so it doesnt get lost.

