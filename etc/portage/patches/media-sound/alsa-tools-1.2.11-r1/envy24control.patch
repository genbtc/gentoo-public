diff '--color=auto' -ru ./config.c ./envy24control/config.c
--- a/config.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/config.c	2025-03-05 15:00:25.009937251 -0500
@@ -46,8 +46,10 @@
 
 void config_set_stereo(GtkWidget *but, gpointer data)
 {
-  gint i=(gint)data;
-  config_stereo[i]=GTK_TOGGLE_BUTTON(but)->active;
+//  gint i=(gint)data;
+  gintptr i = (gintptr)data;
+//  config_stereo[i]=GTK_TOGGLE_BUTTON(but)->active;
+  config_stereo[i]=gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(but));
 }
 
 void config_restore_stereo()
diff '--color=auto' -ru ./configure.ac ./envy24control/configure.ac
--- a/configure.ac	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/configure.ac	2025-03-05 15:00:51.474937227 -0500
@@ -5,6 +5,6 @@
 AM_INIT_AUTOMAKE
 AM_MAINTAINER_MODE([enable])
 
-PKG_CHECK_MODULES(ENVY24CONTROL, gtk+-2.0 alsa >= 0.9.0)
+PKG_CHECK_MODULES(ENVY24CONTROL, gtk+-3.0 alsa >= 0.9.0)
 
 AC_OUTPUT(Makefile desktop/Makefile)
diff '--color=auto' -ru ./driverevents.c ./envy24control/driverevents.c
--- a/driverevents.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/driverevents.c	2025-03-05 15:00:25.009937251 -0500
@@ -19,7 +19,8 @@
 
 #include "envy24control.h"
 
-void control_input_callback(gpointer data, gint source, GdkInputCondition condition)
+//void control_input_callback(gpointer data, gint source, GdkInputCondition condition)
+gint control_input_callback(GIOChannel *source, GIOCondition condition, gpointer data)
 {
 	snd_ctl_t *ctl = (snd_ctl_t *)data;
 	snd_ctl_event_t *ev;
@@ -29,12 +30,12 @@
 
 	snd_ctl_event_alloca(&ev);
 	if (snd_ctl_read(ctl, ev) < 0)
-		return;
+		return FALSE;
 	name = snd_ctl_event_elem_get_name(ev);
 	index = snd_ctl_event_elem_get_index(ev);
 	mask = snd_ctl_event_elem_get_mask(ev);
 	if (! (mask & (SND_CTL_EVENT_MASK_VALUE | SND_CTL_EVENT_MASK_INFO)))
-		return;
+		return FALSE;
 
 	switch (snd_ctl_event_elem_get_interface(ev)) {
 	case SND_CTL_ELEM_IFACE_MIXER:
@@ -84,5 +85,6 @@
 	default:
 		break;
 	}
+	return TRUE;
 }
 
diff '--color=auto' -ru ./envy24control.c ./envy24control/envy24control.c
--- a/envy24control.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/envy24control.c	2025-03-05 15:00:25.009937251 -0500
@@ -45,7 +45,7 @@
 GtkWidget *mixer_mix_drawing;
 GtkWidget *mixer_clear_peaks_button;
 GtkWidget *mixer_drawing[20];
-GtkObject *mixer_adj[20][2];
+GtkAdjustment *mixer_adj[20][2];
 GtkWidget *mixer_vscale[20][2];
 GtkWidget *mixer_mute_toggle[20][2];
 GtkWidget *mixer_stereo_toggle[20];
@@ -71,7 +71,7 @@
 GtkWidget *hw_rate_locking_check;
 GtkWidget *hw_rate_reset_check;
 
-GtkObject *hw_volume_change_adj;
+GtkAdjustment *hw_volume_change_adj;
 GtkWidget *hw_volume_change_spin;
 
 GtkWidget *hw_spdif_profi_nonaudio_radio;
@@ -115,9 +115,9 @@
 GtkWidget *hw_phono_input_on_radio;
 GtkWidget *hw_phono_input_off_radio;
 
-GtkObject *av_dac_volume_adj[10];
-GtkObject *av_adc_volume_adj[10];
-GtkObject *av_ipga_volume_adj[10];
+GtkAdjustment *av_dac_volume_adj[10];
+GtkAdjustment *av_adc_volume_adj[10];
+GtkAdjustment *av_ipga_volume_adj[10];
 GtkLabel *av_dac_volume_label[10];
 GtkLabel *av_adc_volume_label[10];
 GtkLabel *av_ipga_volume_label[10];
@@ -130,7 +130,7 @@
 } profiles_toggle_buttons[MAX_PROFILES];
 
 GtkWidget *active_button = NULL;
-GtkObject *card_number_adj;
+GtkAdjustment *card_number_adj;
 
 
 static void create_mixer_frame(GtkWidget *box, int stream)
@@ -139,7 +139,7 @@
 	GtkWidget *vbox1;
 	GtkWidget *hbox;
 	GtkWidget *frame;
-	GtkObject *adj;
+	GtkAdjustment *adj;
 	GtkWidget *vscale;
 	GtkWidget *drawing;
 	GtkWidget *label;
@@ -192,9 +192,13 @@
 	gtk_box_pack_start(GTK_BOX(hbox), vscale, TRUE, FALSE, 0);
 	gtk_scale_set_value_pos(GTK_SCALE(vscale), GTK_POS_BOTTOM);
 	gtk_scale_set_digits(GTK_SCALE(vscale), 0);
-	gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
+/*	gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
 			   GTK_SIGNAL_FUNC(mixer_adjust),
 			   (gpointer)(long)((stream << 16) + 0));
+*/
+	g_signal_connect(adj, "value_changed",
+			   G_CALLBACK(mixer_adjust),
+			   (gpointer)(long)((stream << 16) + 0));
 
 	vbox1 = gtk_vbox_new(FALSE, 0);
 	gtk_widget_show(vbox1);
@@ -205,12 +209,19 @@
 	sprintf(drawname, "Mixer%i", stream);
 	gtk_widget_set_name(drawing, drawname);
 	gtk_widget_show(drawing);
-	gtk_signal_connect(GTK_OBJECT(drawing), "expose_event",
+/*	gtk_signal_connect(GTK_OBJECT(drawing), "expose_event",
 			   GTK_SIGNAL_FUNC(level_meters_expose_event), NULL);
 	gtk_signal_connect(GTK_OBJECT(drawing), "configure_event",
 			   GTK_SIGNAL_FUNC(level_meters_configure_event), NULL);
+*/
+	g_signal_connect(drawing, "expose_event",
+			   G_CALLBACK(level_meters_expose_event), NULL);
+	g_signal_connect(drawing, "configure_event",
+			   G_CALLBACK(level_meters_configure_event), NULL);
 	gtk_widget_set_events(drawing, GDK_EXPOSURE_MASK);
-	gtk_widget_set_usize(drawing, 36, (60 * tall_equal_mixer_ht + 204));
+//	gtk_widget_set_usize(drawing, 36, (60 * tall_equal_mixer_ht + 204));
+	gtk_widget_set_size_request(drawing, 36, (60 * tall_equal_mixer_ht + 204));
+
 	gtk_box_pack_start(GTK_BOX(vbox1), drawing, FALSE, FALSE, 1);
 
 	label = gtk_label_new("");
@@ -225,10 +236,14 @@
 	gtk_box_pack_start(GTK_BOX(hbox), vscale, TRUE, FALSE, 0);
 	gtk_scale_set_value_pos(GTK_SCALE(vscale), GTK_POS_BOTTOM);
 	gtk_scale_set_digits(GTK_SCALE(vscale), 0);
-	gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
+/*	gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
 			   GTK_SIGNAL_FUNC(mixer_adjust),
 			   (gpointer)(long)((stream << 16) + 1));
-	
+*/
+	g_signal_connect(adj, "value_changed",
+			   G_CALLBACK(mixer_adjust),
+			   (gpointer)(long)((stream << 16) + 1));
+
 	hbox = gtk_hbox_new(TRUE, 0);
 	gtk_widget_show(hbox);
 	gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, FALSE, 0);
@@ -237,7 +252,7 @@
 	gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
 	gtk_widget_show(label);
 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 0);
-	
+
 	label = gtk_label_new("Right");
 	gtk_misc_set_alignment(GTK_MISC(label), 1, 0.5);
 	gtk_widget_show(label);
@@ -248,8 +263,11 @@
 	gtk_widget_show(toggle);
 	gtk_box_pack_end(GTK_BOX(vbox), toggle, FALSE, FALSE, 0);
 	/* gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggle), TRUE); */
-	gtk_signal_connect(GTK_OBJECT(toggle), "toggled",
+/*	gtk_signal_connect(GTK_OBJECT(toggle), "toggled",
 			   GTK_SIGNAL_FUNC(config_set_stereo), (gpointer)stream-1);
+*/
+	g_signal_connect(toggle, "toggled",
+			   G_CALLBACK(config_set_stereo), (gpointer)stream-1);
 
 	hbox = gtk_hbox_new(TRUE, 6);
 	gtk_widget_show(hbox);
@@ -260,18 +278,26 @@
 	gtk_widget_show(toggle);
 	gtk_box_pack_start(GTK_BOX(hbox), toggle, FALSE, TRUE, 0);
 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggle), TRUE);
-	gtk_signal_connect(GTK_OBJECT(toggle), "toggled",
+/*	gtk_signal_connect(GTK_OBJECT(toggle), "toggled",
 			   GTK_SIGNAL_FUNC(mixer_toggled_mute),
 			   (gpointer)(long)((stream << 16) + 0));
+*/
+	g_signal_connect(toggle, "toggled",
+			   G_CALLBACK(mixer_toggled_mute),
+			   (gpointer)(long)((stream << 16) + 0));
 
 	toggle = gtk_toggle_button_new_with_label("Mute");
 	mixer_mute_toggle[stream-1][1] = toggle;
 	gtk_widget_show(toggle);
 	gtk_box_pack_start(GTK_BOX(hbox), toggle, FALSE, TRUE, 0);
 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggle), TRUE);
-	gtk_signal_connect(GTK_OBJECT(toggle), "toggled",
+/*	gtk_signal_connect(GTK_OBJECT(toggle), "toggled",
 			   GTK_SIGNAL_FUNC(mixer_toggled_mute),
 			   (gpointer)(long)((stream << 16) + 1));
+*/
+	g_signal_connect(toggle, "toggled",
+			   G_CALLBACK(mixer_toggled_mute),
+			   (gpointer)(long)((stream << 16) + 1));
 }
 
 
@@ -449,13 +475,15 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, str1);
 	router_radio[stream-1][0] = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)patchbay_toggled, 
-			   (gpointer)(long)((stream << 16) + 0));
-
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)patchbay_toggled, 
+// 			   (gpointer)(long)((stream << 16) + 0));
+	g_signal_connect(radiobutton, "toggled",
+			G_CALLBACK(patchbay_toggled),
+			(gpointer)(long)((stream << 16) + 0));
 
 	hseparator = gtk_hseparator_new();
 	gtk_widget_show(hseparator);
@@ -468,15 +496,19 @@
 	if( (stream <= 2) /* hw1/2 */ ||
 	    ((stream > MAX_OUTPUT_CHANNELS) && (stream <= MAX_OUTPUT_CHANNELS + 2)) /* spdif1/2 */
 	    ) {
-		radiobutton = gtk_radio_button_new_with_label(group, stream & 1 ? "Digital Mix L" : "Digital Mix R");
+//		radiobutton = gtk_radio_button_new_with_label(group, stream & 1 ? "Digital Mix L" : "Digital Mix R");
+        radiobutton = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(radiobutton), stream & 1 ? "Digital Mix L" : "Digital Mix R");
 		router_radio[stream-1][1] = radiobutton;
-		group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//		group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 		gtk_widget_show(radiobutton);
 		gtk_box_pack_start(GTK_BOX(vbox), 
 				    radiobutton, FALSE, FALSE, 0);
-		gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-				  (GtkSignalFunc)patchbay_toggled, 
-				   (gpointer)(long)((stream << 16) + 1));
+//		gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 				  (GtkSignalFunc)patchbay_toggled, 
+// 				   (gpointer)(long)((stream << 16) + 1));
+		g_signal_connect(radiobutton, "toggled",
+				G_CALLBACK(patchbay_toggled),
+				(gpointer)(long)((stream << 16) + 1));
 	}
 	else {
 	  label = gtk_label_new("");
@@ -484,22 +516,25 @@
 	  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
 	}
 
-
 	hseparator = gtk_hseparator_new();
 	gtk_widget_show(hseparator);
 	gtk_box_pack_start(GTK_BOX(vbox), hseparator, FALSE, TRUE, 0);
 
 
 	for(idx = 2 - spdif_channels; idx < input_channels + 2; idx++) {
-		radiobutton = gtk_radio_button_new_with_label(group, table[idx]);
+//		radiobutton = gtk_radio_button_new_with_label(group, table[idx]);
+		radiobutton = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(radiobutton), table[idx]);
 		router_radio[stream-1][2+idx] = radiobutton;
-		group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//		group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 		gtk_widget_show(radiobutton);
 		gtk_box_pack_start(GTK_BOX(vbox), 
 				    radiobutton, FALSE, FALSE, 0);
-		gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-				  (GtkSignalFunc)patchbay_toggled, 
-				   (gpointer)(long)((stream << 16) + 2 + idx));
+//		gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 				  (GtkSignalFunc)patchbay_toggled, 
+// 				   (gpointer)(long)((stream << 16) + 2 + idx));
+		g_signal_connect(radiobutton, "toggled",
+				G_CALLBACK(patchbay_toggled),
+				(gpointer)(long)((stream << 16) + 2 + idx));
 	}
 }
 
@@ -563,75 +598,88 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Int 22050");
 	hw_master_clock_xtal_22050 = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)internal_clock_toggled, 
+//			  (gpointer)"22050");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(internal_clock_toggled),
 			  (gpointer)"22050");
 
-
 	radiobutton = gtk_radio_button_new_with_label(group, "Int 32000");
 	hw_master_clock_xtal_32000 = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)internal_clock_toggled, 
+//			  (gpointer)"32000");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(internal_clock_toggled),
 			  (gpointer)"32000");
 
-
 	radiobutton = gtk_radio_button_new_with_label(group, "Int 44100");
 	hw_master_clock_xtal_44100 = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
-			  (gpointer)"44100");
-
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)internal_clock_toggled, 
+// 			  (gpointer)"44100");
+	g_signal_connect(radiobutton, "toggled",
+              G_CALLBACK(internal_clock_toggled),
+              (gpointer)"44100");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Int 48000");
 	hw_master_clock_xtal_48000 = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)internal_clock_toggled, 
+//			  (gpointer)"48000");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(internal_clock_toggled),
 			  (gpointer)"48000");
 
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Int 88200");
 	hw_master_clock_xtal_88200 = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
-			  (gpointer)"88200");
-
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)internal_clock_toggled, 
+// 			  (gpointer)"88200");
+	g_signal_connect(radiobutton, "toggled",
+              G_CALLBACK(internal_clock_toggled),
+              (gpointer)"88200");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Int 96000");
 	hw_master_clock_xtal_96000 = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
-			  (gpointer)"96000");
-
-
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)internal_clock_toggled, 
+// 			  (gpointer)"96000");
+	g_signal_connect(radiobutton, "toggled",
+              G_CALLBACK(internal_clock_toggled),
+              (gpointer)"96000");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "S/PDIF In");
 	hw_master_clock_spdif_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
-			  (gpointer)"SPDIF");
-
-
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)internal_clock_toggled, 
+// 			  (gpointer)"SPDIF");
+	g_signal_connect(radiobutton, "toggled",
+              G_CALLBACK(internal_clock_toggled),
+              (gpointer)"SPDIF");
 
 	if (card_eeprom.subvendor != ICE1712_SUBDEVICE_DELTA1010 &&
 	    card_eeprom.subvendor != ICE1712_SUBDEVICE_DELTA1010LT)
@@ -639,13 +687,16 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Word Clock");
 	hw_master_clock_word_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)internal_clock_toggled, 
-			  (gpointer)"WordClock");
-	
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)internal_clock_toggled, 
+// 			  (gpointer)"WordClock");
+	g_signal_connect(radiobutton, "toggled",
+              G_CALLBACK(internal_clock_toggled),
+              (gpointer)"WordClock");
+
         label = gtk_label_new("Locked");
         hw_master_clock_status_label = label;
         gtk_widget_show(label);
@@ -671,19 +722,23 @@
 	hw_rate_locking_check = check;
 	gtk_widget_show(check);
 	gtk_box_pack_start(GTK_BOX(hbox), check, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(check), "toggled",
-			  (GtkSignalFunc)rate_locking_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(check), "toggled",
+//			  (GtkSignalFunc)rate_locking_toggled, 
+//			  (gpointer)"locked");
+	g_signal_connect(check, "toggled",
+			  G_CALLBACK(rate_locking_toggled),
 			  (gpointer)"locked");
 
-
 	check = gtk_check_button_new_with_label("Reset");
 	hw_rate_reset_check = check;
 	gtk_widget_show(check);
 	gtk_box_pack_start(GTK_BOX(hbox), check, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(check), "toggled",
-			  (GtkSignalFunc)rate_reset_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(check), "toggled",
+//			  (GtkSignalFunc)rate_reset_toggled, 
+//			  (gpointer)"reset");
+	g_signal_connect(check, "toggled",
+			  G_CALLBACK(rate_reset_toggled),
 			  (gpointer)"reset");
-
 }
 
 static void create_actual_rate(GtkWidget *box)
@@ -707,7 +762,7 @@
 {
 	GtkWidget *frame;
 	GtkWidget *hbox;
-	GtkObject *spinbutton_adj;
+	GtkAdjustment *spinbutton_adj;
 	GtkWidget *spinbutton;
 	GtkWidget *label;
 
@@ -731,9 +786,10 @@
 	gtk_widget_show(spinbutton);
 	gtk_box_pack_start(GTK_BOX(hbox), spinbutton, TRUE, FALSE, 0);
 	gtk_spin_button_set_numeric(GTK_SPIN_BUTTON(spinbutton), TRUE);
-	gtk_signal_connect(GTK_OBJECT(spinbutton_adj), "value_changed",
-			   GTK_SIGNAL_FUNC(volume_change_rate_adj), NULL);
-	
+//	gtk_signal_connect(GTK_OBJECT(spinbutton_adj), "value_changed",
+//			   GTK_SIGNAL_FUNC(volume_change_rate_adj), NULL);
+	g_signal_connect(spinbutton_adj, "value_changed",
+			   G_CALLBACK(volume_change_rate_adj), NULL);
 }
 
 static void create_spdif_output_settings_profi_data(GtkWidget *box)
@@ -756,21 +812,27 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Non-audio");
 	hw_spdif_profi_nonaudio_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_data_toggled, 
-			  (gpointer)"Non-audio");
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)profi_data_toggled, 
+// 			  (gpointer)"Non-audio");
+	g_signal_connect(radiobutton, "toggled",
+ 			  G_CALLBACK(profi_data_toggled),
+ 			  (gpointer)"Non-audio");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Audio");
 	hw_spdif_profi_audio_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_data_toggled, 
-			  (gpointer)"Audio");
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)profi_data_toggled, 
+// 			  (gpointer)"Audio");
+	g_signal_connect(radiobutton, "toggled",
+ 			  G_CALLBACK(profi_data_toggled),
+ 			  (gpointer)"Audio");
 }
 
 static void create_spdif_output_settings_profi_stream(GtkWidget *box)
@@ -792,21 +854,28 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Stereophonic");
 	hw_profi_stream_stereo_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_stream_toggled, 
-			  (gpointer)"Stereo");
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)profi_stream_toggled, 
+// 			  (gpointer)"Stereo");
+	g_signal_connect(radiobutton, "toggled",
+ 			  G_CALLBACK(profi_stream_toggled),
+ 			  (gpointer)"Stereo");
+
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Not indicated");
 	hw_profi_stream_notid_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_stream_toggled, 
-			  (gpointer)"NOTID");
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+// 			  (GtkSignalFunc)profi_stream_toggled, 
+// 			  (gpointer)"NOTID");
+	g_signal_connect(radiobutton, "toggled",
+ 			  G_CALLBACK(profi_stream_toggled),
+ 			  (gpointer)"NOTID");
 }
 
 static void create_spdif_output_settings_profi_emphasis(GtkWidget *box)
@@ -829,38 +898,50 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "No emphasis");
 	hw_profi_emphasis_none_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_emphasis_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)profi_emphasis_toggled, 
+//			  (gpointer)"No");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(profi_emphasis_toggled),
 			  (gpointer)"No");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "50/15us");
 	hw_profi_emphasis_5015_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_emphasis_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)profi_emphasis_toggled, 
+//			  (gpointer)"5015");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(profi_emphasis_toggled),
 			  (gpointer)"5015");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "CCITT J.17");
 	hw_profi_emphasis_ccitt_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_emphasis_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)profi_emphasis_toggled, 
+//			  (gpointer)"CCITT");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(profi_emphasis_toggled),
 			  (gpointer)"CCITT");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Not indicated");
 	hw_profi_emphasis_notid_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)profi_emphasis_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)profi_emphasis_toggled, 
+//			  (gpointer)"NOTID");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(profi_emphasis_toggled),
 			  (gpointer)"NOTID");
 }
 
@@ -906,7 +987,7 @@
 	frame = gtk_frame_new("Copyright");
 	gtk_widget_show(frame);
 	gtk_box_pack_start(GTK_BOX(box), frame, FALSE, TRUE, 0);
-	
+
 	vbox = gtk_vbox_new(FALSE, 0);
 	gtk_widget_show(vbox);
 	gtk_container_add(GTK_CONTAINER(frame), vbox);
@@ -915,20 +996,26 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Copyrighted");
 	hw_consumer_copyright_on_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_copyright_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_copyright_toggled, 
+//			  (gpointer)"Copyright");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_copyright_toggled),
 			  (gpointer)"Copyright");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Copy permitted");
 	hw_consumer_copyright_off_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_copyright_toggled,
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_copyright_toggled,
+//			  (gpointer)"Permitted");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_copyright_toggled),
 			  (gpointer)"Permitted");
 }
 
@@ -951,20 +1038,26 @@
 	radiobutton = gtk_radio_button_new_with_label(group,
 						      "1-st generation");
 	hw_consumer_copy_1st_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_copy_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_copy_toggled, 
+//			  (gpointer)"1st");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_copy_toggled),
 			  (gpointer)"1st");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Original");
 	hw_consumer_copy_original_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_copy_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_copy_toggled, 
+//			  (gpointer)"Original");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_copy_toggled),
 			  (gpointer)"Original");
 }
 
@@ -986,20 +1079,26 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "No emphasis");
 	hw_consumer_emphasis_none_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_emphasis_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_emphasis_toggled, 
+//			  (gpointer)"No");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_emphasis_toggled),
 			  (gpointer)"No");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "50/15us");
 	hw_consumer_emphasis_5015_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_emphasis_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_emphasis_toggled, 
+//			  (gpointer)"5015");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_emphasis_toggled),
 			  (gpointer)"5015");
 }
 
@@ -1021,38 +1120,50 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "DAT");
 	hw_consumer_category_dat_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_category_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_category_toggled, 
+//			  (gpointer)"DAT");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_category_toggled),
 			  (gpointer)"DAT");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "PCM encoder");
 	hw_consumer_category_pcm_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_category_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_category_toggled, 
+//			  (gpointer)"PCM");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_category_toggled),
 			  (gpointer)"PCM");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "CD (ICE-908)");
 	hw_consumer_category_cd_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_category_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_category_toggled, 
+//			  (gpointer)"CD");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_category_toggled),
 			  (gpointer)"CD");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "General");
 	hw_consumer_category_general_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)consumer_category_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)consumer_category_toggled, 
+//			  (gpointer)"General");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(consumer_category_toggled),
 			  (gpointer)"General");
 }
 
@@ -1122,22 +1233,28 @@
 
 	radiobutton = gtk_radio_button_new_with_label(NULL, "Professional");
 	hw_spdif_professional_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(hbox), radiobutton, FALSE, FALSE, 0);
 	gtk_container_set_border_width(GTK_CONTAINER(radiobutton), 6);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)spdif_output_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)spdif_output_toggled, 
+//			  (gpointer)"Professional");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(spdif_output_toggled),
 			  (gpointer)"Professional");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Consumer");
 	hw_spdif_consumer_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(hbox), radiobutton, FALSE, FALSE, 0);
 	gtk_container_set_border_width(GTK_CONTAINER(radiobutton), 6);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)spdif_output_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)spdif_output_toggled, 
+//			  (gpointer)"Consumer");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(spdif_output_toggled),
 			  (gpointer)"Consumer");
 
 
@@ -1174,34 +1291,54 @@
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Coaxial");
 	hw_spdif_input_coaxial_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)spdif_input_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)spdif_input_toggled, 
+//			  (gpointer)"Coaxial");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(spdif_input_toggled),
 			  (gpointer)"Coaxial");
 
 	radiobutton = gtk_radio_button_new_with_label(group, "Optical");
 	hw_spdif_input_optical_radio = radiobutton;
-	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//	group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	gtk_widget_show(radiobutton);
 	gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-			  (GtkSignalFunc)spdif_input_toggled, 
+//	gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//			  (GtkSignalFunc)spdif_input_toggled, 
+//			  (gpointer)"Optical");
+	g_signal_connect(radiobutton, "toggled",
+			  G_CALLBACK(spdif_input_toggled),
 			  (gpointer)"Optical");
 
-        radiobutton = gtk_radio_button_new_with_label(group, "Internal CD");
-        hw_spdif_switch_off_radio = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+    radiobutton = gtk_radio_button_new_with_label(group, "Internal CD");
+    hw_spdif_switch_off_radio = radiobutton;
+//  group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 	if(card_is_dmx6fire)
 	        gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)spdif_input_toggled,
-                          (gpointer)"Off");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)spdif_input_toggled,
+//                          (gpointer)"Off");
+        g_signal_connect(radiobutton, "toggled",
+                      G_CALLBACK(spdif_input_toggled),
+                      (gpointer)"Off");
 
         if(hide)
-                gtk_widget_hide_all(frame);
+//                gtk_widget_hide_all(frame);
+		{
+			GtkWidget *child;
+			GList *children = gtk_container_get_children(GTK_CONTAINER(frame));
+
+			for (GList *iter = children; iter != NULL; iter = iter->next) {
+			    child = GTK_WIDGET(iter->data);
+			    gtk_widget_hide(child);
+			}
+
+			g_list_free(children);  // Free the list of children
+		}
 }
 
 
@@ -1228,24 +1365,41 @@
 
         radiobutton = gtk_radio_button_new_with_label(group, "Phono");
         hw_phono_input_on_radio = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
         gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)phono_input_toggled,
-                          (gpointer)"Phono");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)phono_input_toggled,
+//                          (gpointer)"Phono");
+        g_signal_connect(radiobutton, "toggled",
+                      G_CALLBACK(phono_input_toggled),
+                      (gpointer)"Phono");
 
         radiobutton = gtk_radio_button_new_with_label(group, "Mic");
         hw_phono_input_off_radio = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
         gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)phono_input_toggled,
-                          (gpointer)"Mic");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)phono_input_toggled,
+//                          (gpointer)"Mic");
+        g_signal_connect(radiobutton, "toggled",
+	                  G_CALLBACK(phono_input_toggled),
+                      (gpointer)"Mic");
 
         if(hide)
-                gtk_widget_hide_all(frame);
+//                gtk_widget_hide_all(frame);
+		{
+			GtkWidget *child;
+			GList *children = gtk_container_get_children(GTK_CONTAINER(frame));
+
+			for (GList *iter = children; iter != NULL; iter = iter->next) {
+			    child = GTK_WIDGET(iter->data);
+			    gtk_widget_hide(child);
+			}
+
+			g_list_free(children);  // Free the list of children
+		}
 }
 
 static void create_input_interface(GtkWidget *box)
@@ -1271,42 +1425,65 @@
 
         radiobutton = gtk_radio_button_new_with_label(group, "Internal");
         input_interface_internal = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
         gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)analog_input_select_toggled,
-                          (gpointer)"Internal");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)analog_input_select_toggled,
+//                          (gpointer)"Internal");
+        g_signal_connect(radiobutton, "toggled",
+                      G_CALLBACK(analog_input_select_toggled),
+                      (gpointer)"Internal");
 
         radiobutton = gtk_radio_button_new_with_label(group, "Front Input");
         input_interface_front_input = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
         gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)analog_input_select_toggled,
-                          (gpointer)"Front Input");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)analog_input_select_toggled,
+//                          (gpointer)"Front Input");
+        g_signal_connect(radiobutton, "toggled",
+                      G_CALLBACK(analog_input_select_toggled),
+                      (gpointer)"Front Input");
 
         radiobutton = gtk_radio_button_new_with_label(group, "Rear Input");
         input_interface_rear_input = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
         gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)analog_input_select_toggled,
-                          (gpointer)"Rear Input");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)analog_input_select_toggled,
+//                          (gpointer)"Rear Input");
+        g_signal_connect(radiobutton, "toggled",
+                      G_CALLBACK(analog_input_select_toggled),
+                      (gpointer)"Rear Input");
 
         radiobutton = gtk_radio_button_new_with_label(group, "Wavetable");
         input_interface_wavetable = radiobutton;
-        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//        group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
         gtk_widget_show(radiobutton);
         gtk_box_pack_start(GTK_BOX(vbox), radiobutton, FALSE, FALSE, 0);
-        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-                          (GtkSignalFunc)analog_input_select_toggled,
-                          (gpointer)"Wave Table");
+//        gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//                          (GtkSignalFunc)analog_input_select_toggled,
+//                          (gpointer)"Wave Table");
+        g_signal_connect(radiobutton, "toggled",
+                      G_CALLBACK(analog_input_select_toggled),
+                      (gpointer)"Wave Table");
 
         if(hide)
-                gtk_widget_hide_all(frame);
+//                gtk_widget_hide_all(frame);
+		{
+			GtkWidget *child;
+			GList *children = gtk_container_get_children(GTK_CONTAINER(frame));
+
+			for (GList *iter = children; iter != NULL; iter = iter->next) {
+			    child = GTK_WIDGET(iter->data);
+			    gtk_widget_hide(child);
+			}
+
+			g_list_free(children);  // Free the list of children
+		}
 }
 
 static void create_hardware(GtkWidget *main, GtkWidget *notebook, int page)
@@ -1447,7 +1624,7 @@
 	GtkWidget *hbox;
 	GtkWidget *vbox;
 	GtkWidget *frame;
-	GtkObject *adj;
+	GtkAdjustment *adj;
 	GtkWidget *vscale;
 	GtkWidget *radiobutton;
 	GSList *group;
@@ -1521,8 +1698,11 @@
 		gtk_widget_show(vscale);
 		gtk_box_pack_start(GTK_BOX(vbox), vscale, TRUE, TRUE, 6);
 		gtk_scale_set_digits(GTK_SCALE(vscale), 0);
-		gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
-				   GTK_SIGNAL_FUNC(dac_volume_adjust), 
+//		gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
+//				   GTK_SIGNAL_FUNC(dac_volume_adjust), 
+//				   (gpointer)(long)(i));
+		g_signal_connect(adj, "value_changed",
+				   G_CALLBACK(dac_volume_adjust),
 				   (gpointer)(long)(i));
 
 	        label = gtk_label_new("000");
@@ -1535,16 +1715,19 @@
 			continue;
 		group = NULL;
 		for (j = 0; j < envy_dac_sense_items(); j++) {
-		  radiobutton = gtk_radio_button_new_with_label(group, 
+		    radiobutton = gtk_radio_button_new_with_label(group, 
 								envy_dac_sense_enum_name(j));
 			av_dac_sense_radio[i][j] = radiobutton;
 			gtk_widget_show(radiobutton);
-			gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-					  (GtkSignalFunc)dac_sense_toggled, 
-					   (gpointer)(long)((i << 8) + j));
+//			gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//					  (GtkSignalFunc)dac_sense_toggled, 
+//					   (gpointer)(long)((i << 8) + j));
+			g_signal_connect(radiobutton, "toggled",
+						G_CALLBACK(dac_sense_toggled),
+						(gpointer)(long)((i << 8) + j));
 			gtk_box_pack_start(GTK_BOX(vbox), 
 					    radiobutton, FALSE, TRUE, 0);
-			group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//			group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 		}
 	}
 
@@ -1578,8 +1761,11 @@
 		gtk_box_pack_start(GTK_BOX(vbox), vscale, TRUE, TRUE, 6);
 		gtk_scale_set_value_pos(GTK_SCALE(vscale), GTK_POS_BOTTOM);
 		gtk_scale_set_digits(GTK_SCALE(vscale), 0);
-		gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
-				   GTK_SIGNAL_FUNC(adc_volume_adjust), 
+//		gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
+//				   GTK_SIGNAL_FUNC(adc_volume_adjust), 
+//				   (gpointer)(long)(i));
+		g_signal_connect(adj, "value_changed",
+				   G_CALLBACK(adc_volume_adjust),
 				   (gpointer)(long)(i));
 
 	        label = gtk_label_new("000");
@@ -1595,12 +1781,15 @@
 								      envy_adc_sense_enum_name(j));
 			av_adc_sense_radio[i][j] = radiobutton;
 			gtk_widget_show(radiobutton);
-			gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
-					  (GtkSignalFunc)adc_sense_toggled, 
-					   (gpointer)(long)((i << 8) + j));
+//			gtk_signal_connect(GTK_OBJECT(radiobutton), "toggled",
+//					  (GtkSignalFunc)adc_sense_toggled, 
+//					   (gpointer)(long)((i << 8) + j));
+			g_signal_connect(radiobutton, "toggled",
+					  G_CALLBACK(adc_sense_toggled),
+					  (gpointer)(long)((i << 8) + j));
 			gtk_box_pack_start(GTK_BOX(vbox), 
 					    radiobutton, FALSE, TRUE, 0);
-			group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
+//			group = gtk_radio_button_group(GTK_RADIO_BUTTON(radiobutton));
 		}
 	}
 
@@ -1634,8 +1823,11 @@
 		gtk_box_pack_start(GTK_BOX(vbox), vscale, TRUE, TRUE, 6);
 		gtk_scale_set_value_pos(GTK_SCALE(vscale), GTK_POS_BOTTOM);
 		gtk_scale_set_digits(GTK_SCALE(vscale), 0);
-		gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
-				   GTK_SIGNAL_FUNC(ipga_volume_adjust), 
+//		gtk_signal_connect(GTK_OBJECT(adj), "value_changed",
+//				   GTK_SIGNAL_FUNC(ipga_volume_adjust), 
+//				   (gpointer)(long)(i));
+		g_signal_connect(adj, "value_changed",
+				   G_CALLBACK(ipga_volume_adjust),
 				   (gpointer)(long)(i));
 
 	        label = gtk_label_new("000");
@@ -1671,19 +1863,24 @@
 	gint card_nr;
 	gint index;
 
-	if (!(GTK_TOGGLE_BUTTON (delete_button)->active))
+//	if (!(GTK_TOGGLE_BUTTON (delete_button)->active))
+	if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(delete_button)))
 		return EXIT_SUCCESS;
 
-	card_nr = GTK_ADJUSTMENT (card_number_adj)->value;
+//	card_nr = GTK_ADJUSTMENT (card_number_adj)->value;
+	card_nr = gtk_adjustment_get_value(GTK_ADJUSTMENT(card_number_adj));
+
 	if ((card_nr < 0) || (card_nr >= MAX_CARD_NUMBERS)) {
 		fprintf(stderr, "card number not in [0 ... %d]\n", MAX_CARD_NUMBERS - 1);
-		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (delete_button), FALSE);
+//		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (delete_button), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(delete_button), FALSE);
 		return -EINVAL;
 	}
 
 	res = delete_card(card_number, profiles_file_name);
 	if (res < 0) {
-		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (delete_button), FALSE);
+//		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (delete_button), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (delete_button), FALSE);
 		return res;
 	}
 	if (card_nr == card_number) {
@@ -1693,7 +1890,8 @@
 		}
 	}
 
-	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (delete_button), FALSE);
+//	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (delete_button), FALSE);
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (delete_button), FALSE);
 
 	return EXIT_SUCCESS;
 }
@@ -1712,18 +1910,21 @@
 	gint res;
 	gint index;
 
-	if (!(GTK_TOGGLE_BUTTON (save_button)->active))
+//	if (!(GTK_TOGGLE_BUTTON (save_button)->active))
+	if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(save_button)))
 		return EXIT_SUCCESS;
 	if ((index = index_active_profile()) >= 0) {
 		res = save_restore(ALSACTL_OP_STORE, index + 1, card_number, profiles_file_name, \
 			gtk_entry_get_text(GTK_ENTRY (profiles_toggle_buttons[index].entry)));
 	} else {
 		fprintf(stderr, "No active profile found.\n");
-		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (save_button), FALSE);
+//		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (save_button), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (save_button), FALSE);
 		return -EXIT_FAILURE;
 	}
 
-	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (save_button), FALSE);
+//	gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (save_button), FALSE);
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (save_button), FALSE);
 
 	return res;
 }
@@ -1734,21 +1935,27 @@
 	gint profile_number;
 
 	if (active_button == toggle_button) {
-		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (toggle_button), TRUE);
+//		gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (toggle_button), TRUE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (toggle_button), TRUE);
 		gtk_editable_set_editable(GTK_EDITABLE (entry), TRUE);
 		gtk_widget_grab_focus(entry);
 		return;
-	} else if (GTK_TOGGLE_BUTTON (toggle_button)->active) {
+//	} else if (GTK_TOGGLE_BUTTON (toggle_button)->active) {
+	} else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggle_button))) {
 		active_button = toggle_button;
 	}
-	gtk_editable_set_editable(GTK_EDITABLE (entry), GTK_TOGGLE_BUTTON (toggle_button)->active);
-	if (GTK_TOGGLE_BUTTON (toggle_button)->active) {
+//	gtk_editable_set_editable(GTK_EDITABLE (entry), GTK_TOGGLE_BUTTON (toggle_button)->active);
+	gtk_editable_set_editable(GTK_EDITABLE(entry), gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggle_button)));
+
+//	if (GTK_TOGGLE_BUTTON (toggle_button)->active) {
+	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggle_button))) {
 		gtk_widget_grab_focus(entry);
 		profile_number = NOTFOUND;
 		for (index = 0; index < MAX_PROFILES; index++)
 		{
 			if (profiles_toggle_buttons[index].toggle_button != toggle_button) {
-				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (profiles_toggle_buttons[index].toggle_button), FALSE);
+//				gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (profiles_toggle_buttons[index].toggle_button), FALSE);
+				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (profiles_toggle_buttons[index].toggle_button), FALSE);
 			} else {
 				profile_number = index + 1;
 			}
@@ -1774,18 +1981,25 @@
 	box = gtk_hbox_new(FALSE, 0);
 
 	toggle_button = gtk_toggle_button_new();
-	gtk_container_border_width(GTK_CONTAINER(toggle_button), 3);
+//	gtk_container_border_width(GTK_CONTAINER(toggle_button), 3);
+	gtk_container_set_border_width(GTK_CONTAINER(toggle_button), 3);
 
 	profiles_toggle_buttons[index].entry = entry_label = gtk_entry_new();
 	gtk_entry_set_max_length(GTK_ENTRY (entry_label), MAX_PROFILE_NAME_LENGTH);
 	gtk_entry_set_text(GTK_ENTRY (entry_label), profile_name);
 	/* only the active profile can be modified */
 	gtk_editable_set_editable(GTK_EDITABLE (entry_label), FALSE);
-	gtk_signal_connect(GTK_OBJECT (entry_label), "activate",
-			 GTK_SIGNAL_FUNC (enter_callback),
+//	gtk_signal_connect(GTK_OBJECT (entry_label), "activate",
+//			 GTK_SIGNAL_FUNC (enter_callback),
+//			 (gpointer) entry_label);
+//	gtk_signal_connect(GTK_OBJECT (toggle_button), "toggled",
+//			 GTK_SIGNAL_FUNC (entry_toggle_editable),
+//			 (gpointer) entry_label);
+	g_signal_connect(entry_label, "activate",
+			 G_CALLBACK(enter_callback),
 			 (gpointer) entry_label);
-	gtk_signal_connect(GTK_OBJECT (toggle_button), "toggled",
-			 GTK_SIGNAL_FUNC (entry_toggle_editable),
+	g_signal_connect(toggle_button, "toggled",
+			 G_CALLBACK(entry_toggle_editable),
 			 (gpointer) entry_label);
 
 	gtk_box_pack_start(GTK_BOX (box), entry_label, FALSE, FALSE, 20);
@@ -1806,7 +2020,7 @@
 	GtkWidget *hbox1;
 	GtkWidget *save_button;
 	GtkWidget *delete_button;
-	GtkObject *card_button_adj;
+	GtkAdjustment *card_button_adj;
 	GtkWidget *card_button;
 	GtkWidget *scrolledwindow;
 	GtkWidget *viewport;
@@ -1847,18 +2061,24 @@
 	/* Create button boxes */
 	vbox1 = gtk_vbutton_box_new();
 
-	gtk_vbutton_box_set_spacing_default(0);
+//	gtk_vbutton_box_set_spacing_default(0);
+//	gtk_button_box_set_spacing(GTK_BUTTON_BOX(delete_button), 0); //didnt work
+	gtk_box_set_spacing(GTK_BOX(delete_button), 0);
+
+
 	for (index = 0; index < MAX_PROFILES; index++)	{
 		profile_name = get_profile_name(index + 1, card_number, profiles_file_name);
 		profiles_toggle_buttons[index].toggle_button = toggle_button_entry(window, profile_name, index);
 		gtk_box_pack_start(GTK_BOX (vbox1), profiles_toggle_buttons[index].toggle_button, FALSE, FALSE, 0);
 	}
 	gtk_widget_show(vbox1);
-	gtk_container_border_width(GTK_CONTAINER(vbox1), 6);
+//	gtk_container_border_width(GTK_CONTAINER(vbox1), 6);
+	gtk_container_set_border_width(GTK_CONTAINER(vbox1), 6);
 
 	vbox2 = gtk_vbutton_box_new();
 	gtk_widget_show(vbox2);
-	gtk_container_border_width(GTK_CONTAINER(vbox2), 50);
+//	gtk_container_border_width(GTK_CONTAINER(vbox2), 50);
+	gtk_container_set_border_width(GTK_CONTAINER(vbox2), 50);
 
 	hbox1 = gtk_hbox_new(FALSE, 0);
 	gtk_widget_show(hbox1);
@@ -1880,15 +2100,21 @@
 	delete_button = gtk_toggle_button_new_with_label("Delete card from profiles");
 	gtk_widget_show(delete_button);
 	gtk_box_pack_start(GTK_BOX (vbox2), delete_button, FALSE, FALSE, 20);
-	gtk_signal_connect(GTK_OBJECT (delete_button), "toggled",
-			 GTK_SIGNAL_FUNC (delete_card_number),
+//	gtk_signal_connect(GTK_OBJECT (delete_button), "toggled",
+//			 GTK_SIGNAL_FUNC (delete_card_number),
+//			 NULL);
+	g_signal_connect(delete_button, "toggled",
+			 G_CALLBACK(delete_card_number),
 			 NULL);
 
 	save_button = gtk_toggle_button_new_with_label("Save active profile");
 	gtk_widget_show(save_button);
 	gtk_box_pack_end(GTK_BOX (vbox2), save_button, FALSE, FALSE, 20);
-	gtk_signal_connect(GTK_OBJECT (save_button), "toggled",
-			 GTK_SIGNAL_FUNC (save_active_profile),
+//	gtk_signal_connect(GTK_OBJECT (save_button), "toggled",
+//			 GTK_SIGNAL_FUNC (save_active_profile),
+//			 NULL);
+	g_signal_connect(save_button, "toggled",
+			 G_CALLBACK(save_active_profile),
 			 NULL);
 
 	gtk_container_add(GTK_CONTAINER(hbox), vbox1);
@@ -1915,7 +2141,8 @@
 			profile_number = get_profile_number(default_profile, card_number, profiles_file_name);
 		}
 		if ((profile_number > 0) && (profile_number <= MAX_PROFILES)) {
-			gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (profiles_toggle_buttons[profile_number - 1].toggle_button), TRUE);
+//			gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON (profiles_toggle_buttons[profile_number - 1].toggle_button), TRUE);
+			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON (profiles_toggle_buttons[profile_number - 1].toggle_button), TRUE);
 		} else {
 			fprintf(stderr, "Cannot find profile '%s' for card '%d'.\n", default_profile, card_number);
 		}
@@ -1960,14 +2187,20 @@
 	gtk_widget_set_name(drawing, "DigitalMixer");
 	gtk_box_pack_start(GTK_BOX(hbox1), drawing, TRUE, FALSE, 6);
 	if (tall_equal_mixer_ht > 1 ) {
-		gtk_widget_set_usize(drawing, 60, 264 + 60 * (tall_equal_mixer_ht - 1));
+//		gtk_widget_set_usize(drawing, 60, 264 + 60 * (tall_equal_mixer_ht - 1));
+		gtk_widget_set_size_request(drawing, 60, 264 + 60 * (tall_equal_mixer_ht - 1));
 	} else {
-		gtk_widget_set_usize(drawing, 60, 264);
+//		gtk_widget_set_usize(drawing, 60, 264);
+		gtk_widget_set_size_request(drawing, 60, 264);
 	}
-	gtk_signal_connect(GTK_OBJECT(drawing), "expose_event",
-			   (GtkSignalFunc)level_meters_expose_event, NULL);
-	gtk_signal_connect(GTK_OBJECT(drawing), "configure_event",
-			   (GtkSignalFunc)level_meters_configure_event, NULL);
+//	gtk_signal_connect(GTK_OBJECT(drawing), "expose_event",
+//			   (GtkSignalFunc)level_meters_expose_event, NULL);
+//	gtk_signal_connect(GTK_OBJECT(drawing), "configure_event",
+//			   (GtkSignalFunc)level_meters_configure_event, NULL);
+	g_signal_connect(drawing, "expose_event",
+			   G_CALLBACK(level_meters_expose_event), NULL);
+	g_signal_connect(drawing, "configure_event",
+			   G_CALLBACK(level_meters_configure_event), NULL);
 	gtk_widget_set_events(drawing, GDK_EXPOSURE_MASK);
 	gtk_widget_show(drawing);
 
@@ -1991,8 +2224,10 @@
 	gtk_widget_show(mixer_clear_peaks_button);
 	gtk_box_pack_start(GTK_BOX(vbox), mixer_clear_peaks_button, TRUE, FALSE, 0);
 	gtk_container_set_border_width(GTK_CONTAINER(mixer_clear_peaks_button), 4);
-	gtk_signal_connect(GTK_OBJECT(mixer_clear_peaks_button), "clicked",
-			   GTK_SIGNAL_FUNC(level_meters_reset_peaks), NULL);
+//	gtk_signal_connect(GTK_OBJECT(mixer_clear_peaks_button), "clicked",
+//			   GTK_SIGNAL_FUNC(level_meters_reset_peaks), NULL);
+	g_signal_connect(mixer_clear_peaks_button, "clicked",
+			   G_CALLBACK(level_meters_reset_peaks), NULL);
 }/* End create_outer  */
 
 static void create_blank(GtkWidget *main, GtkWidget *notebook, int page)
@@ -2258,8 +2493,10 @@
         /* Create the main window */
         window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
         gtk_window_set_title(GTK_WINDOW(window), title);
-        gtk_signal_connect(GTK_OBJECT (window), "delete_event", 
-                           (GtkSignalFunc) gtk_main_quit, NULL);
+//        gtk_signal_connect(GTK_OBJECT (window), "delete_event", 
+//                           (GtkSignalFunc) gtk_main_quit, NULL);
+        g_signal_connect(window, "delete_event",
+                       G_CALLBACK(gtk_main_quit), NULL);
         signal(SIGINT, (void *)gtk_main_quit);
 
 	gtk_window_set_default_size(GTK_WINDOW(window), wwidth, 300);
@@ -2294,20 +2531,35 @@
 		pfds = alloca(sizeof(*pfds) * npfds);
 		npfds = snd_ctl_poll_descriptors(ctl, pfds, npfds);
 		for (i = 0; i < npfds; i++)
-			gdk_input_add(pfds[i].fd,
-				      GDK_INPUT_READ,
-				      control_input_callback,
-				      ctl);
+//			gdk_input_add(pfds[i].fd,
+//				      GDK_INPUT_READ,
+//				      control_input_callback,
+//				      ctl);
+//			g_io_add_watch(pfds[i].fd, G_IO_IN, control_input_callback, NULL); //didnt work
+		{
+			GIOChannel *channel = g_io_channel_unix_new(pfds[i].fd);
+			g_io_add_watch(channel, G_IO_IN, control_input_callback, NULL);
+			g_io_channel_unref(channel);
+		}
+
 		snd_ctl_subscribe_events(ctl, 1);
 	}
 	if (midi_fd >= 0) {
-		gdk_input_add(midi_fd, GDK_INPUT_READ, midi_process, NULL);
-	}
-	gtk_timeout_add(40, level_meters_timeout_callback, NULL);
-	gtk_timeout_add(100, master_clock_status_timeout_callback, NULL);
-	gtk_timeout_add(100, internal_clock_status_timeout_callback, NULL);
-	gtk_timeout_add(100, rate_locking_status_timeout_callback, NULL);
-	gtk_timeout_add(100, rate_reset_status_timeout_callback, NULL);
+//		gdk_input_add(midi_fd, GDK_INPUT_READ, midi_process, NULL);
+		GIOChannel *channel = g_io_channel_unix_new(midi_fd);
+		g_io_add_watch(channel, G_IO_IN, midi_process, NULL);
+		g_io_channel_unref(channel);  // Don't forget to unref the GIOChannel when done
+	}
+//	gtk_timeout_add(40, level_meters_timeout_callback, NULL);
+//	gtk_timeout_add(100, master_clock_status_timeout_callback, NULL);
+//	gtk_timeout_add(100, internal_clock_status_timeout_callback, NULL);
+//	gtk_timeout_add(100, rate_locking_status_timeout_callback, NULL);
+//	gtk_timeout_add(100, rate_reset_status_timeout_callback, NULL);
+	g_timeout_add(40, level_meters_timeout_callback, NULL);
+	g_timeout_add(100, master_clock_status_timeout_callback, NULL);
+	g_timeout_add(100, internal_clock_status_timeout_callback, NULL);
+	g_timeout_add(100, rate_locking_status_timeout_callback, NULL);
+	g_timeout_add(100, rate_reset_status_timeout_callback, NULL);
 
 
 	gtk_widget_show(window);
diff '--color=auto' -ru ./envy24control.h ./envy24control/envy24control.h
--- a/envy24control.h	2025-03-05 15:08:03.890936839 -0500
+++ b/envy24control/envy24control.h	2025-03-05 15:00:36.790937240 -0500
@@ -85,7 +85,7 @@
 extern GtkWidget *mixer_mix_drawing;
 extern GtkWidget *mixer_clear_peaks_button;
 extern GtkWidget *mixer_drawing[20];
-extern GtkObject *mixer_adj[20][2];
+extern GtkAdjustment *mixer_adj[20][2];
 extern GtkWidget *mixer_vscale[20][2];
 extern GtkWidget *mixer_solo_toggle[20][2];
 extern GtkWidget *mixer_mute_toggle[20][2];
@@ -108,7 +108,7 @@
 extern GtkWidget *hw_rate_locking_check;
 extern GtkWidget *hw_rate_reset_check;
 
-extern GtkObject *hw_volume_change_adj;
+extern GtkAdjustment *hw_volume_change_adj;
 extern GtkWidget *hw_volume_change_spin;
 
 extern GtkWidget *hw_spdif_profi_nonaudio_radio;
@@ -151,9 +151,9 @@
 extern GtkWidget *input_interface_front_input;
 extern GtkWidget *input_interface_rear_input;
 extern GtkWidget *input_interface_wavetable;
-extern GtkObject *av_dac_volume_adj[];
-extern GtkObject *av_adc_volume_adj[];
-extern GtkObject *av_ipga_volume_adj[];
+extern GtkAdjustment *av_dac_volume_adj[];
+extern GtkAdjustment *av_adc_volume_adj[];
+extern GtkAdjustment *av_ipga_volume_adj[];
 extern GtkLabel *av_dac_volume_label[];
 extern GtkLabel *av_adc_volume_label[];
 extern GtkLabel *av_ipga_volume_label[];
@@ -238,6 +238,6 @@
 void dac_sense_toggled(GtkWidget *togglebutton, gpointer data);
 void adc_sense_toggled(GtkWidget *togglebutton, gpointer data);
 
-void control_input_callback(gpointer data, gint source, GdkInputCondition condition);
-void mixer_input_callback(gpointer data, gint source, GdkInputCondition condition);
+gint control_input_callback(GIOChannel *source, GIOCondition condition, gpointer data);
+gint mixer_input_callback(GIOChannel *source, GIOCondition condition, gpointer data);
 
diff '--color=auto' -ru ./hardware.c ./envy24control/hardware.c
--- a/hardware.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/hardware.c	2025-03-05 15:00:25.009937251 -0500
@@ -39,7 +39,8 @@
 
 static int is_active(GtkWidget *widget)
 {
-	return GTK_TOGGLE_BUTTON(widget)->active ? 1 : 0;
+//	return GTK_TOGGLE_BUTTON(widget)->active ? 1 : 0;
+	return gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
 }
 
 void master_clock_update(void)
@@ -353,8 +354,9 @@
 void volume_change_rate_adj(GtkAdjustment *adj, gpointer data)
 {
 	int err;
-	
-	snd_ctl_elem_value_set_integer(volume_rate, 0, adj->value);
+	double adjustment_value = gtk_adjustment_get_value(adj);
+//	snd_ctl_elem_value_set_integer(volume_rate, 0, adj->value);
+	snd_ctl_elem_value_set_integer(volume_rate, 0, adjustment_value);
 	if ((err = snd_ctl_elem_write(ctl, volume_rate)) < 0)
 		g_print("Unable to write volume change rate: %s\n", snd_strerror(err));
 }
@@ -598,7 +600,8 @@
 			page = 1;
 		}
 		spdif_output_write();
-		gtk_notebook_set_page(GTK_NOTEBOOK(hw_spdif_output_notebook), page);
+//		gtk_notebook_set_page(GTK_NOTEBOOK(hw_spdif_output_notebook), page);
+		gtk_notebook_set_current_page(GTK_NOTEBOOK(hw_spdif_output_notebook), page);
 		spdif_output_update();
 	}
 }
diff '--color=auto' -ru ./levelmeters.c ./envy24control/levelmeters.c
--- a/levelmeters.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/levelmeters.c	2025-03-05 15:00:25.009937251 -0500
@@ -19,13 +19,20 @@
 
 #include "envy24control.h"
 
-static GdkGC *penGreenShadow[21] = { NULL, };
-static GdkGC *penGreenLight[21] = { NULL, };
-static GdkGC *penOrangeShadow[21] = { NULL, };
-static GdkGC *penOrangeLight[21] = { NULL, };
-static GdkGC *penRedShadow[21] = { NULL, };
-static GdkGC *penRedLight[21] = { NULL, };
-static GdkPixmap *pixmap[21] = { NULL, };
+//static GdkGC *penGreenShadow[21] = { NULL, };
+//static GdkGC *penGreenLight[21] = { NULL, };
+//static GdkGC *penOrangeShadow[21] = { NULL, };
+//static GdkGC *penOrangeLight[21] = { NULL, };
+//static GdkGC *penRedShadow[21] = { NULL, };
+//static GdkGC *penRedLight[21] = { NULL, };
+static GdkRGBA *penGreenShadow[21] = { NULL, };
+static GdkRGBA *penGreenLight[21] = { NULL, };
+static GdkRGBA *penOrangeShadow[21] = { NULL, };
+static GdkRGBA *penOrangeLight[21] = { NULL, };
+static GdkRGBA *penRedShadow[21] = { NULL, };
+static GdkRGBA *penRedLight[21] = { NULL, };
+//static GdkPixmap *pixmap[21] = { NULL, };
+static GdkPixbuf *pixmap[21] = { NULL, };
 static snd_ctl_elem_value_t *peaks;
 
 extern int input_channels, output_channels, pcm_output_channels, spdif_channels, view_spdif_playback;
@@ -50,11 +57,11 @@
 	}
 }
 
+/*
 static GdkGC *get_pen(int idx, int nRed, int nGreen, int nBlue)
 {
 	GdkColor *c;
 	GdkGC *gc;
-	
 	c = (GdkColor *)g_malloc(sizeof(GdkColor));
 	c->red = nRed;
 	c->green = nGreen;
@@ -64,8 +71,29 @@
 	gdk_gc_set_foreground(gc, c);
 	return gc;
 }
+*/
+static GdkRGBA get_pen_obj(int idx, int nRed, int nGreen, int nBlue)
+{
+    GdkRGBA rgba;
+    // Set the RGBA values (assuming RGBA range is [0.0, 1.0])
+    rgba.red = nRed / 255.0;
+    rgba.green = nGreen / 255.0;
+    rgba.blue = nBlue / 255.0;
+    rgba.alpha = 1.0; // Fully opaque
+    return rgba;
+}
+static GdkRGBA *get_pen(int idx, int nRed, int nGreen, int nBlue)
+{
+    GdkRGBA *c = g_malloc(sizeof(GdkRGBA));
+    c->red = nRed / 255.0;
+    c->green = nGreen / 255.0;
+    c->blue = nBlue / 255.0;
+    c->alpha = 1.0; // Fully opaque
+    return c;
+}
 
-static int get_index(gchar *name)
+
+static int get_index(const gchar *name)
 {
 	int result;
 
@@ -90,16 +118,44 @@
 	int seg;
 	int segs_on1 = ((segments * level1) + 128) / 255;
 	int segs_on2 = ((segments * level2) + 128) / 255;
+	// pixmap[idx]' is a GdkDrawable
+//	cairo_t *cr = gdk_cairo_create(pixmap[idx]);
+    // Assuming pixmap[idx] is a GdkPixbuf
+    GdkPixbuf *pixbuf = pixmap[idx];
+    // Create a Cairo surface from the GdkPixbuf
+    cairo_surface_t *surface = gdk_cairo_surface_create_from_pixbuf(pixbuf, 0, NULL);
+    // Create a Cairo context from the surface
+    cairo_t *cr = cairo_create(surface);
+
 
 	// g_print("segs_on1 = %i (%i), segs_on2 = %i (%i)\n", segs_on1, level1, segs_on2, level2);
 	for (seg = 0; seg < green_segments; seg++) {
+/*
 		gdk_draw_rectangle(pixmap[idx],
 				   segs_on1 > 0 ? penGreenLight[idx] : penGreenShadow[idx],
 				   TRUE,
 				   6, 3 + ((segments - seg - 1) * 4),
 				   segment_width,
 				   3);
+*/
+		// Set the drawing color
+		if (segs_on1 > 0) {
+		    cairo_set_source_rgb(cr, penGreenLight[idx]->red,
+		                             penGreenLight[idx]->green,
+		                             penGreenLight[idx]->blue);
+		} else {
+		    cairo_set_source_rgb(cr, penGreenShadow[idx]->red,
+		                             penGreenShadow[idx]->green,
+		                             penGreenShadow[idx]->blue);
+		}
+
+		// Set the rectangle and draw
+		cairo_rectangle(cr, 6, 3 + ((segments - seg - 1) * 4), segment_width, 3);
+		cairo_fill(cr);
+
+
 		if (stereo)
+/*
 			gdk_draw_rectangle(pixmap[idx],
 					   segs_on2 > 0 ? penGreenLight[idx] : penGreenShadow[idx],
 					   TRUE,
@@ -107,45 +163,131 @@
 					   3 + ((segments - seg - 1) * 4),
 					   segment_width,
 					   3);
+*/
+		{
+			// Set the drawing color
+			if (segs_on2 > 0) {
+			    cairo_set_source_rgb(cr, penGreenLight[idx]->red,
+			                             penGreenLight[idx]->green,
+			                             penGreenLight[idx]->blue);
+			} else {
+			    cairo_set_source_rgb(cr, penGreenShadow[idx]->red,
+			                             penGreenShadow[idx]->green,
+			                             penGreenShadow[idx]->blue);
+			}
+
+			// Set the rectangle and draw
+			cairo_rectangle(cr, 2 + (width / 2), 3 + ((segments - seg - 1) * 4), segment_width, 3);
+			cairo_fill(cr);
+		}
 		segs_on1--;
 		segs_on2--;
+
 	}
 	for (seg = green_segments; seg < green_segments + orange_segments; seg++) {
-		gdk_draw_rectangle(pixmap[idx],
+		// Set the drawing color
+		if (segs_on1 > 0) {
+		    cairo_set_source_rgb(cr, penOrangeLight[idx]->red,
+		                             penOrangeLight[idx]->green,
+		                             penOrangeLight[idx]->blue);
+		} else {
+		    cairo_set_source_rgb(cr, penOrangeShadow[idx]->red,
+		                             penOrangeShadow[idx]->green,
+		                             penOrangeShadow[idx]->blue);
+		}
+
+		// Set the rectangle and draw
+		cairo_rectangle(cr, 6, 3 + ((segments - seg - 1) * 4), segment_width, 3);
+		cairo_fill(cr);
+/*		gdk_draw_rectangle(pixmap[idx],
 				   segs_on1 > 0 ? penOrangeLight[idx] : penOrangeShadow[idx],
 				   TRUE,
 				   6, 3 + ((segments - seg - 1) * 4),
 				   segment_width,
 				   3);
+*/
 		if (stereo)
-			gdk_draw_rectangle(pixmap[idx],
+		{
+
+			// Set the drawing color
+			if (segs_on2 > 0) {
+			    cairo_set_source_rgb(cr, penOrangeLight[idx]->red,
+			                             penOrangeLight[idx]->green,
+			                             penOrangeLight[idx]->blue);
+			} else {
+			    cairo_set_source_rgb(cr, penOrangeShadow[idx]->red,
+			                             penOrangeShadow[idx]->green,
+			                             penOrangeShadow[idx]->blue);
+			}
+
+			// Set the rectangle and draw
+			cairo_rectangle(cr, 2 + (width / 2), 3 + ((segments - seg - 1) * 4), segment_width, 3);
+			cairo_fill(cr);
+		}
+/*			gdk_draw_rectangle(pixmap[idx],
 					   segs_on2 > 0 ? penOrangeLight[idx] : penOrangeShadow[idx],
 					   TRUE,
 					   2 + (width / 2),
 					   3 + ((segments - seg - 1) * 4),
 					   segment_width,
 					   3);
+*/
 		segs_on1--;
 		segs_on2--;
 	}
 	for (seg = green_segments + orange_segments; seg < segments; seg++) {
-		gdk_draw_rectangle(pixmap[idx],
+/*		gdk_draw_rectangle(pixmap[idx],
 				   segs_on1 > 0 ? penRedLight[idx] : penRedShadow[idx],
 				   TRUE,
 				   6, 3 + ((segments - seg - 1) * 4),
 				   segment_width,
 				   3);
+*/
+		// Set the drawing color
+		if (segs_on1 > 0) {
+		    cairo_set_source_rgb(cr, penRedLight[idx]->red,
+		                             penRedLight[idx]->green,
+		                             penRedLight[idx]->blue);
+		} else {
+		    cairo_set_source_rgb(cr, penRedShadow[idx]->red,
+		                             penRedShadow[idx]->green,
+		                             penRedShadow[idx]->blue);
+		}
+
+		// Set the rectangle and draw
+		cairo_rectangle(cr, 6, 3 + ((segments - seg - 1) * 4), segment_width, 3);
+		cairo_fill(cr);
+
 		if (stereo)
-			gdk_draw_rectangle(pixmap[idx],
+		{
+			// Set the drawing color based on segs_on2
+			if (segs_on2 > 0) {
+			    cairo_set_source_rgb(cr, penRedLight[idx]->red,
+			                             penRedLight[idx]->green,
+			                             penRedLight[idx]->blue);
+			} else {
+			    cairo_set_source_rgb(cr, penRedShadow[idx]->red,
+			                             penRedShadow[idx]->green,
+			                             penRedShadow[idx]->blue);
+			}
+
+			// Set the rectangle and draw
+			cairo_rectangle(cr, 2 + (width / 2), 3 + ((segments - seg - 1) * 4), segment_width, 3);
+			cairo_fill(cr);
+		}
+/*			gdk_draw_rectangle(pixmap[idx],
 					   segs_on2 > 0 ? penRedLight[idx] : penRedShadow[idx],
 					   TRUE,
 					   2 + (width / 2),
 					   3 + ((segments - seg - 1) * 4),
 					   segment_width,
 					   3);
+*/
 		segs_on1--;
 		segs_on2--;
 	}
+	// Clean up the Cairo context
+	cairo_destroy(cr);
 }
 
 gint level_meters_configure_event(GtkWidget *widget, GdkEventConfigure *event)
@@ -153,25 +295,61 @@
 	int idx = get_index(gtk_widget_get_name(widget));
 
 	if (pixmap[idx] != NULL)
-		gdk_pixmap_unref(pixmap[idx]);
-	pixmap[idx] = gdk_pixmap_new(widget->window,
-				     widget->allocation.width,
-				     widget->allocation.height,
-				     -1);
+//		gdk_pixmap_unref(pixmap[idx]);
+		g_object_unref(pixmap[idx]);
+//	pixmap[idx] = gdk_pixmap_new(widget->window,
+//				     widget->allocation.width,
+//				     widget->allocation.height,
+//				     -1);
+/*	pixmap[idx] = gdk_window_create_similar_surface(gtk_widget_get_window(widget),
+		CAIRO_FORMAT_ARGB32,
+		gtk_widget_get_allocated_width(widget),
+		gtk_widget_get_allocated_height(widget));
+*/
+	cairo_surface_t *surface = gdk_window_create_similar_surface(gtk_widget_get_window(widget),
+	    CAIRO_FORMAT_ARGB32, gtk_widget_get_allocated_width(widget), gtk_widget_get_allocated_height(widget));
+	// Create a GdkPixbuf from the cairo surface
+	pixmap[idx] = gdk_pixbuf_get_from_surface(surface, 0, 0, gtk_widget_get_allocated_width(widget), gtk_widget_get_allocated_height(widget));
+
 	penGreenShadow[idx] = get_pen(idx, 0, 0x77ff, 0);
 	penGreenLight[idx] = get_pen(idx, 0, 0xffff, 0);
 	penOrangeShadow[idx] = get_pen(idx, 0xddff, 0x55ff, 0);
 	penOrangeLight[idx] = get_pen(idx, 0xffff, 0x99ff, 0);
 	penRedShadow[idx] = get_pen(idx, 0xaaff, 0, 0);
 	penRedLight[idx] = get_pen(idx, 0xffff, 0, 0);
-	gdk_draw_rectangle(pixmap[idx],
-			   widget->style->black_gc,
+
+/*	gdk_draw_rectangle(pixmap[idx],
+			   style_context->black_gc,
 			   TRUE,
 			   0, 0,
-			   widget->allocation.width,
-			   widget->allocation.height);
-	// g_print("configure: %i:%i\n", widget->allocation.width, widget->allocation.height);
-	redraw_meters(idx, widget->allocation.width, widget->allocation.height, 0, 0);
+			   allocation.width,
+			   allocation.height);
+*/
+	// Get the window for the widget
+	GdkWindow *window = gtk_widget_get_window(widget);
+	// Begin drawing on the window (this replaces gdk_cairo_create)
+	GdkDrawingContext *context = gdk_window_begin_draw_frame(window, NULL);
+	// Get the Cairo context from the drawing context
+	cairo_t *cr = gdk_drawing_context_get_cairo_context(context);
+	//cairo_t *cr = gdk_cairo_create(gtk_widget_get_window(widget)); //DEPRECATED
+	GtkAllocation allocation;
+	gtk_widget_get_allocation(widget, &allocation);
+
+	// Set the source color (black in this case)
+	cairo_set_source_rgb(cr, 0.0, 0.0, 0.0);  // RGB for black
+	// Create the rectangle with the specified dimensions
+	cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);
+	// Fill the rectangle (similar to the "TRUE" parameter for filled in gdk_draw_rectangle)
+	cairo_fill(cr);
+
+	// g_print("configure: %i:%i\n", allocation.width, allocation.height);
+	redraw_meters(idx, allocation.width, allocation.height, 0, 0);
+
+    gdk_window_end_draw_frame(window, NULL); // End the draw frame
+
+	// Don't forget to manage memory and clean up
+	cairo_surface_destroy(surface);
+
 	return TRUE;
 }
 
@@ -179,18 +357,39 @@
 {
 	int idx = get_index(gtk_widget_get_name(widget));
 	int l1, l2;
-	
+
 	get_levels(idx, &l1, &l2);
-	redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
-	gdk_draw_pixmap(widget->window,
-			widget->style->black_gc,
-			pixmap[idx],
-			event->area.x, event->area.y,
-			event->area.x, event->area.y,
-			event->area.width, event->area.height);
+	GtkAllocation allocation;
+	gtk_widget_get_allocation(widget, &allocation);
+	redraw_meters(idx, allocation.width, allocation.height, l1, l2);
+//	gdk_draw_pixmap(widget->window,
+//			widget->style->black_gc,
+//			pixmap[idx],
+//			event->area.x, event->area.y,
+//			event->area.x, event->area.y,
+//			event->area.width, event->area.height);
+	// Get the window for the widget
+	GdkWindow *window = gtk_widget_get_window(widget);
+	// Begin drawing on the window (this replaces gdk_cairo_create)
+	GdkDrawingContext *context = gdk_window_begin_draw_frame(window, NULL);
+	// Get the Cairo context from the drawing context
+	cairo_t *cr = gdk_drawing_context_get_cairo_context(context);
+	// Convert GdkPixbuf to Cairo surface
+	cairo_surface_t *surface = gdk_cairo_surface_create_from_pixbuf(pixmap[idx], 0, gtk_widget_get_window(widget));
+	// Set the source surface to the Cairo context
+	cairo_set_source_surface(cr, surface, event->area.x, event->area.y);
+	// Define the area to draw and fill it
+	cairo_rectangle(cr, event->area.x, event->area.y, event->area.width, event->area.height);
+	cairo_fill(cr);
+	// Clean up the Cairo surface
+	cairo_surface_destroy(surface);
+	// End the drawing frame
+	gdk_window_end_draw_frame(window, context);
+
 	return FALSE;
 }
 
+//TODO: Reduce/Remove/Refactor repeated code
 gint level_meters_timeout_callback(gpointer data)
 {
 	GtkWidget *widget;
@@ -200,56 +399,140 @@
 	for (idx = 0; idx <= pcm_output_channels; idx++) {
 		get_levels(idx, &l1, &l2);
 		widget = idx == 0 ? mixer_mix_drawing : mixer_drawing[idx-1];
-		if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
-			redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
-			gdk_draw_pixmap(widget->window,
-					widget->style->black_gc,
-					pixmap[idx],
-					0, 0,
-					0, 0,
-					widget->allocation.width, widget->allocation.height);
+//		if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
+		if (gtk_widget_get_visible(widget) && (pixmap[idx] != NULL)) {
+			GtkAllocation allocation;
+			gtk_widget_get_allocation(widget, &allocation);
+//			redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
+			redraw_meters(idx, allocation.width, allocation.height, l1, l2);
+			//gdk_draw_pixmap(widget->window,
+			//		widget->style->black_gc,
+			//		pixmap[idx],
+			//		0, 0,
+			//		0, 0,
+			//		widget->allocation.width, widget->allocation.height);
+			// Get the window for the widget
+			GdkWindow *window = gtk_widget_get_window(widget);
+			// Begin drawing on the window
+			GdkDrawingContext *context = gdk_window_begin_draw_frame(window, NULL);
+			// Get the Cairo context from the drawing context
+			cairo_t *cr = gdk_drawing_context_get_cairo_context(context);
+			// Create a Cairo surface from the pixmap
+			cairo_surface_t *surface = gdk_cairo_surface_create_from_pixbuf(pixmap[idx], 0, window);
+			// Set the source surface to the pixmap (Cairo surface)
+			cairo_set_source_surface(cr, surface, 0, 0);
+			// Define the area to draw (same as the width and height of the widget)
+			cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);
+			cairo_fill(cr); // Fill the rectangle with the pixmap
+			// Clean up the Cairo surface
+			cairo_surface_destroy(surface);
+			// End the drawing frame
+			gdk_window_end_draw_frame(window, context);
 		}
 	}
 	if (view_spdif_playback) {
 		for (idx = MAX_PCM_OUTPUT_CHANNELS + 1; idx <= MAX_OUTPUT_CHANNELS + spdif_channels; idx++) {
 			get_levels(idx, &l1, &l2);
 			widget = idx == 0 ? mixer_mix_drawing : mixer_drawing[idx-1];
-			if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
-				redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
-				gdk_draw_pixmap(widget->window,
-						widget->style->black_gc,
-						pixmap[idx],
-						0, 0,
-						0, 0,
-						widget->allocation.width, widget->allocation.height);
+//			if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
+			if (gtk_widget_get_visible(widget) && (pixmap[idx] != NULL)) {
+				GtkAllocation allocation;
+				gtk_widget_get_allocation(widget, &allocation);
+//				redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
+				redraw_meters(idx, allocation.width, allocation.height, l1, l2);
+//				gdk_draw_pixmap(widget->window,
+//						widget->style->black_gc,
+//						pixmap[idx],
+//						0, 0,
+//						0, 0,
+//						widget->allocation.width, widget->allocation.height);
+			// Get the window for the widget
+			GdkWindow *window = gtk_widget_get_window(widget);
+			// Begin drawing on the window
+			GdkDrawingContext *context = gdk_window_begin_draw_frame(window, NULL);
+			// Get the Cairo context from the drawing context
+			cairo_t *cr = gdk_drawing_context_get_cairo_context(context);
+			// Create a Cairo surface from the pixmap
+			cairo_surface_t *surface = gdk_cairo_surface_create_from_pixbuf(pixmap[idx], 0, window);
+			// Set the source surface to the pixmap (Cairo surface)
+			cairo_set_source_surface(cr, surface, 0, 0);
+			// Define the area to draw (same as the width and height of the widget)
+			cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);
+			cairo_fill(cr); // Fill the rectangle with the pixmap
+			// Clean up the Cairo surface
+			cairo_surface_destroy(surface);
+			// End the drawing frame
+			gdk_window_end_draw_frame(window, context);
 			}
 		}
 	}
 	for (idx = MAX_PCM_OUTPUT_CHANNELS + MAX_SPDIF_CHANNELS + 1; idx <= input_channels + MAX_PCM_OUTPUT_CHANNELS + MAX_SPDIF_CHANNELS; idx++) {
 		get_levels(idx, &l1, &l2);
 		widget = idx == 0 ? mixer_mix_drawing : mixer_drawing[idx-1];
-		if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
-			redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
-			gdk_draw_pixmap(widget->window,
-					widget->style->black_gc,
-					pixmap[idx],
-					0, 0,
-					0, 0,
-					widget->allocation.width, widget->allocation.height);
+		//if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
+		if (gtk_widget_get_visible(widget) && (pixmap[idx] != NULL)) {
+			GtkAllocation allocation;
+			gtk_widget_get_allocation(widget, &allocation);
+//			redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
+			redraw_meters(idx, allocation.width, allocation.height, l1, l2);
+//			gdk_draw_pixmap(widget->window,
+//					widget->style->black_gc,
+//					pixmap[idx],
+//					0, 0,
+//					0, 0,
+//					widget->allocation.width, widget->allocation.height);
+			// Get the window for the widget
+			GdkWindow *window = gtk_widget_get_window(widget);
+			// Begin drawing on the window
+			GdkDrawingContext *context = gdk_window_begin_draw_frame(window, NULL);
+			// Get the Cairo context from the drawing context
+			cairo_t *cr = gdk_drawing_context_get_cairo_context(context);
+			// Create a Cairo surface from the pixmap
+			cairo_surface_t *surface = gdk_cairo_surface_create_from_pixbuf(pixmap[idx], 0, window);
+			// Set the source surface to the pixmap (Cairo surface)
+			cairo_set_source_surface(cr, surface, 0, 0);
+			// Define the area to draw (same as the width and height of the widget)
+			cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);
+			cairo_fill(cr); // Fill the rectangle with the pixmap
+			// Clean up the Cairo surface
+			cairo_surface_destroy(surface);
+			// End the drawing frame
+			gdk_window_end_draw_frame(window, context);
 		}
 	}
 	for (idx = MAX_PCM_OUTPUT_CHANNELS + MAX_SPDIF_CHANNELS + MAX_INPUT_CHANNELS + 1; \
 		    idx <= spdif_channels + MAX_PCM_OUTPUT_CHANNELS + MAX_SPDIF_CHANNELS + MAX_INPUT_CHANNELS; idx++) {
 		get_levels(idx, &l1, &l2);
 		widget = idx == 0 ? mixer_mix_drawing : mixer_drawing[idx-1];
-		if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
-			redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
-			gdk_draw_pixmap(widget->window,
-					widget->style->black_gc,
-					pixmap[idx],
-					0, 0,
-					0, 0,
-					widget->allocation.width, widget->allocation.height);
+		//if (GTK_WIDGET_VISIBLE(widget) && (pixmap[idx] != NULL)) {
+		if (gtk_widget_get_visible(widget) && (pixmap[idx] != NULL)) {
+			GtkAllocation allocation;
+			gtk_widget_get_allocation(widget, &allocation);
+//			redraw_meters(idx, widget->allocation.width, widget->allocation.height, l1, l2);
+			redraw_meters(idx, allocation.width, allocation.height, l1, l2);
+//			gdk_draw_pixmap(widget->window,
+//					widget->style->black_gc,
+//					pixmap[idx],
+//					0, 0,
+//					0, 0,
+//					widget->allocation.width, widget->allocation.height);
+			// Get the window for the widget
+			GdkWindow *window = gtk_widget_get_window(widget);
+			// Begin drawing on the window
+			GdkDrawingContext *context = gdk_window_begin_draw_frame(window, NULL);
+			// Get the Cairo context from the drawing context
+			cairo_t *cr = gdk_drawing_context_get_cairo_context(context);
+			// Create a Cairo surface from the pixmap
+			cairo_surface_t *surface = gdk_cairo_surface_create_from_pixbuf(pixmap[idx], 0, window);
+			// Set the source surface to the pixmap (Cairo surface)
+			cairo_set_source_surface(cr, surface, 0, 0);
+			// Define the area to draw (same as the width and height of the widget)
+			cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);
+			cairo_fill(cr); // Fill the rectangle with the pixmap
+			// Clean up the Cairo surface
+			cairo_surface_destroy(surface);
+			// End the drawing frame
+			gdk_window_end_draw_frame(window, context);
 		}
 	}
 	return TRUE;
diff '--color=auto' -ru ./midi.c ./envy24control/midi.c
--- a/midi.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/midi.c	2025-03-05 15:00:25.009937251 -0500
@@ -243,7 +243,8 @@
 void mixer_adjust(GtkAdjustment *adj, gpointer data);
 void mixer_set_mute(int stream, int left, int right);
 
-void midi_process(gpointer data, gint source, GdkInputCondition condition)
+//void midi_process(gpointer data, gint source, GdkInputCondition condition)
+gint midi_process(GIOChannel *source, GIOCondition condition, gpointer data)
 {
   snd_seq_event_t *ev;
   static GtkAdjustment *adj=0;
@@ -306,6 +307,7 @@
       snd_seq_free_event(ev);
     }
   while (snd_seq_event_input_pending(seq, 0) > 0);
+  return TRUE;
 }
 
 /* ************************************************* */
diff '--color=auto' -ru ./midi.h ./envy24control/midi.h
--- a/midi.h	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/midi.h	2025-03-05 15:00:36.790937240 -0500
@@ -7,7 +7,8 @@
 int midi_close();
 void midi_maxstreams(int);
 int midi_controller(int c, int v);
-void midi_process(gpointer data, gint source, GdkInputCondition condition);
+//void midi_process(gpointer data, gint source, GIOChannel condition);
+gint midi_process(GIOChannel *source, GIOCondition condition, gpointer data);
 int midi_button(int b, int v);
 
 #endif
diff '--color=auto' -ru ./mixer.c ./envy24control/mixer.c
--- a/mixer.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/mixer.c	2025-03-05 15:00:25.009937251 -0500
@@ -39,7 +39,8 @@
 
 static int is_active(GtkWidget *widget)
 {
-	return GTK_TOGGLE_BUTTON(widget)->active ? 1 : 0;
+//	return GTK_TOGGLE_BUTTON(widget)->active ? 1 : 0;
+	return gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
 }
 
 void mixer_update_stream(int stream, int vol_flag, int sw_flag)
@@ -180,12 +181,20 @@
 	int button = (long)data & 1;
 	int stereo = is_active(mixer_stereo_toggle[stream-1]) ? 1 : 0;
 	int vol[2] = { -1, -1 };
-	
+/*
 	vol[button] = 96 - adj->value;
 	if (stereo) {
 		gtk_adjustment_set_value(GTK_ADJUSTMENT(mixer_adj[stream-1][button ^ 1]), adj->value);
 		vol[button ^ 1] = 96 - adj->value;
 	}
+*/
+	double adjustment_value = gtk_adjustment_get_value(adj);  // Get the value from GtkAdjustment
+
+    vol[button] = 96 - adjustment_value;
+    if (stereo) {
+        gtk_adjustment_set_value(GTK_ADJUSTMENT(mixer_adj[stream-1][button ^ 1]), adjustment_value);
+        vol[button ^ 1] = 96 - adjustment_value;
+    }
 	set_volume1(stream, vol[0], vol[1]);
 }
 
diff '--color=auto' -ru ./patchbay.c ./envy24control/patchbay.c
--- a/patchbay.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/patchbay.c	2025-03-05 15:00:25.009937251 -0500
@@ -30,7 +30,8 @@
 
 static int is_active(GtkWidget *widget)
 {
-	return GTK_TOGGLE_BUTTON(widget)->active ? 1 : 0;
+//	return GTK_TOGGLE_BUTTON(widget)->active ? 1 : 0;
+	return gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
 }
 
 static int get_toggle_index(int stream)
diff '--color=auto' -ru ./volume.c ./envy24control/volume.c
--- a/volume.c	2024-01-29 07:57:31.000000000 -0500
+++ b/envy24control/volume.c	2025-03-05 15:00:25.009937251 -0500
@@ -217,7 +217,9 @@
 {
 	int idx = (int)(long)data;
 	snd_ctl_elem_value_t *val;
-	int err, ival = -(int)adj->value;
+//	int err, ival = -(int)adj->value;
+	double adjustment_value = gtk_adjustment_get_value(adj);
+	int err, ival = -(int)adjustment_value;
 	char text[16];
 
 	snd_ctl_elem_value_alloca(&val);
@@ -235,7 +237,9 @@
 {
 	int idx = (int)(long)data;
 	snd_ctl_elem_value_t *val;
-	int err, ival = -(int)adj->value;
+//	int err, ival = -(int)adj->value;
+	double adjustment_value = gtk_adjustment_get_value(adj);
+	int err, ival = -(int)adjustment_value;
 	char text[16];
 
 	snd_ctl_elem_value_alloca(&val);
@@ -253,7 +257,9 @@
 {
 	int idx = (int)(long)data;
 	snd_ctl_elem_value_t *val;
-	int err, ival = -(int)adj->value;
+//	int err, ival = -(int)adj->value;
+	double adjustment_value = gtk_adjustment_get_value(adj);
+	int err, ival = -(int)adjustment_value;
 	char text[16];
 
 	snd_ctl_elem_value_alloca(&val);
@@ -299,9 +305,6 @@
 		g_print("Unable to write adc sense: %s\n", snd_strerror(err));
 }
 
-/*
- */
-
 void analog_volume_init(void)
 {
 	snd_ctl_elem_info_t *info;
