--- a/echomixer/configure.ac	2024-01-29 07:57:31.000000000 -0500
+++ b/echomixer/configure.ac	2025-03-05 17:38:32.650928735 -0500
@@ -5,6 +5,6 @@
 AM_INIT_AUTOMAKE
 AM_MAINTAINER_MODE([enable])
 
-PKG_CHECK_MODULES(ECHOMIXER, gtk+-2.0 alsa >= 1.0.0)
+PKG_CHECK_MODULES(ECHOMIXER, gtk+-3.0 alsa >= 1.0.0)
 
 AC_OUTPUT(Makefile desktop/Makefile)
--- a/echomixer/echomixer.c	2024-01-29 07:57:31.000000000 -0500
+++ b/echomixer/echomixer.c	2025-03-05 21:18:32.560916888 -0500
@@ -87,6 +87,7 @@
 #include <ctype.h>
 #include <gtk/gtk.h>
 #include <gdk/gdk.h>
+#include <cairo.h>
 #include <alsa/asoundlib.h>
 
 
@@ -136,7 +137,7 @@
   GtkWidget *window;
   GtkWidget *volume[ECHO_MAXAUDIOOUTPUTS];
   GtkWidget *label[ECHO_MAXAUDIOOUTPUTS];
-  GtkObject *adj[ECHO_MAXAUDIOOUTPUTS];
+  GtkAdjustment *adj[ECHO_MAXAUDIOOUTPUTS];
   GtkWidget *outsel[ECHO_MAXAUDIOOUTPUTS];
   GtkWidget *inpsel[ECHO_MAXAUDIOINPUTS];
   GtkWidget *vchsel[ECHO_MAXAUDIOOUTPUTS];
@@ -150,7 +151,7 @@
   GtkWidget *window;
   GtkWidget *volume[ECHO_MAXAUDIOOUTPUTS];
   GtkWidget *label[ECHO_MAXAUDIOOUTPUTS];
-  GtkObject *adj[ECHO_MAXAUDIOOUTPUTS];
+  GtkAdjustment *adj[ECHO_MAXAUDIOOUTPUTS];
   int Gain[ECHO_MAXAUDIOOUTPUTS];
 } lineinControl, lineoutControl, pcmoutControl;
 
@@ -173,10 +174,17 @@
 GtkWidget *VUdarea, *Mixdarea;
 gint VUtimer, Mixtimer, clocksrctimer;
 
-GdkGC *gc=0;
-static GdkPixmap *VUpixmap = NULL;
-static GdkPixmap *Mixpixmap = NULL;
-GdkFont *fnt;
+//GdkGC *gc=0;
+cairo_t *cr = NULL;
+//static GdkPixmap *VUpixmap = NULL;
+//static GdkPixmap *Mixpixmap = NULL;
+static cairo_surface_t *VUpixmap = NULL;
+static cairo_surface_t *Mixpixmap = NULL;
+//GdkFont *fnt;
+// Replace GdkFont with PangoFontDescription for GTK3
+//PangoFontDescription *fnt = pango_font_description_from_string("fixed 10");
+PangoFontDescription *fnt = NULL;
+
 
 void Clock_source_activate(GtkWidget *widget, gpointer clk);
 
@@ -571,19 +579,21 @@
   if (source>=0 && source!=clocksrcVal) {
     // Set the clock source, but do not change the value of AutoClock
     Clock_source_activate(clocksrc_menuitem[source], (gpointer)(long)(source|DONT_CHANGE));
-    gtk_option_menu_set_history(GTK_OPTION_MENU(clocksrcOpt), clocksrcVal);
+//    gtk_option_menu_set_history(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal);
+	gtk_combo_box_set_active(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal);
   }
   return(TRUE);
 }
 
 
-
 void DrawBar(int x, int y, int level, int peak, int gain) {
   GdkColor Bars={0x00FF00, 0, 0, 0};
   GdkColor Bars1={0x000000, 0, 0, 0};
   GdkColor Peak={0x1BABFF, 0, 0, 0};
   GdkColor Level={0xC0B000, 0, 0, 0};
   int db;
+  // Get the drawing context from the widgetâ€™s window
+  cr = gdk_cairo_create(gtk_widget_get_window(window));
 
   x=XMETER+XCELLTOT*x;
   y=YCELLTOT*y+YCELLBORDER;
@@ -591,270 +601,326 @@
   if (level>ECHOGAIN_MUTED) {
     // Draw the "integer" part of the bar
     db=level>>2;
-    gdk_gc_set_foreground(gc, &Bars);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x, y-db, GM_BARWIDTH, YCELLDIM+db);
+//    gdk_gc_set_foreground(gc, &Bars);
+//    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x, y-db, GM_BARWIDTH, YCELLDIM+db);
+	// Set the foreground color (Bars should be a GdkRGBA)
+//	gdk_cairo_set_source_rgba(cr, &Bars);
+	GdkRGBA rgba_color = {
+	    .red = Bars.red / 65535.0,
+	    .green = Bars.green / 65535.0,
+	    .blue = Bars.blue / 65535.0,
+	    .alpha = 1.0 // Assuming full opacity
+	};
+	// Set the color (Bars should be a GdkRGBA)
+	gdk_cairo_set_source_rgba(cr, &rgba_color);
+
+	// Draw the rectangle
+	cairo_rectangle(cr, x, y - db, GM_BARWIDTH, YCELLDIM + db);
+	cairo_fill(cr); // Fill the rectangle with the set color
 
     // Draw the antialiased part
     Bars1.pixel=(level&3) << (6 + 8);	// 4 levels (256/4==64==2^6) of green (2^8)
     if (Bars1.pixel) {
-      gdk_gc_set_foreground(gc, &Bars1);
-      gdk_draw_rectangle(Mixpixmap, gc, TRUE, x, y-db-1, GM_BARWIDTH, 1);
+//      gdk_gc_set_foreground(gc, &Bars1);
+//      gdk_draw_rectangle(Mixpixmap, gc, TRUE, x, y-db-1, GM_BARWIDTH, 1);
+		GdkRGBA rgba_color = {
+		    .red = Bars1.red / 65535.0,
+		    .green = Bars1.green / 65535.0,
+		    .blue = Bars1.blue / 65535.0,
+		    .alpha = 1.0 // Assuming full opacity
+		};
+		// Set the color (Bars1 should be a GdkRGBA)
+		gdk_cairo_set_source_rgba(cr, &rgba_color);
+		// Draw the thin rectangle (1px height)
+		cairo_rectangle(cr, x, y - db - 1, GM_BARWIDTH, 1);
+		cairo_fill(cr);
     }
   }
 
   // Draw the peak
   if (peak>ECHOGAIN_MUTED) {
     db=peak>>2;
-    gdk_gc_set_foreground(gc, &Peak);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x, y-db, GM_BARWIDTH, 1);
+//    gdk_gc_set_foreground(gc, &Peak);
+//    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x, y-db, GM_BARWIDTH, 1);
+	// Set the color (Peak should be a GdkRGBA)
+//	gdk_cairo_set_source_rgba(cr, &Peak);
+	GdkRGBA rgba_color = {
+	    .red = Peak.red / 65535.0,
+	    .green = Peak.green / 65535.0,
+	    .blue = Peak.blue / 65535.0,
+	    .alpha = 1.0 // Assuming full opacity
+	};
+	// Set the color (Peak should be a GdkRGBA)
+	gdk_cairo_set_source_rgba(cr, &rgba_color);
+
+	// Draw the peak indicator (1px height)
+	cairo_rectangle(cr, x, y - db, GM_BARWIDTH, 1);
+	cairo_fill(cr);
   }
 
   // Draw the mixer gain
   if (gain>=ECHOGAIN_MUTED) {
     db=gain>>2;
-    gdk_gc_set_foreground(gc, &Level);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x-XMETER+XVOLUME, y, 1, YCELLDIM);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x-XMETER+XVOLUME-2, y-db, 5, 1);
+//    gdk_gc_set_foreground(gc, &Level);
+//    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x-XMETER+XVOLUME, y, 1, YCELLDIM);
+//    gdk_draw_rectangle(Mixpixmap, gc, TRUE, x-XMETER+XVOLUME-2, y-db, 5, 1);
+	// Set the color for the Level (assuming Level is a GdkRGBA)
+//	gdk_cairo_set_source_rgba(cr, &Level);
+	GdkRGBA rgba_color = {
+	    .red = Level.red / 65535.0,
+	    .green = Level.green / 65535.0,
+	    .blue = Level.blue / 65535.0,
+	    .alpha = 1.0 // Assuming full opacity
+	};
+	gdk_cairo_set_source_rgba(cr, &rgba_color);
+
+	// Draw the first rectangle (vertical line)
+	cairo_rectangle(cr, x - XMETER + XVOLUME, y, 1, YCELLDIM);
+	// Draw the second rectangle (horizontal line)
+	cairo_rectangle(cr, x - XMETER + XVOLUME - 2, y - db, 5, 1);
+	cairo_fill(cr);
   }
+  // Clean up
+  cairo_destroy(cr);
 }
 
-
-
 // Draw the matrix mixer
 gint DrawMixer(gpointer unused) {
-  GdkRectangle update_rect;
-  int InLevel[ECHO_MAXAUDIOINPUTS];
-  int InPeak[ECHO_MAXAUDIOINPUTS];
-  int OutLevel[ECHO_MAXAUDIOOUTPUTS];
-  int OutPeak[ECHO_MAXAUDIOOUTPUTS];
-  int VirLevel[ECHO_MAXAUDIOOUTPUTS];
-  int VirPeak[ECHO_MAXAUDIOOUTPUTS];
-  static int InClip[ECHO_MAXAUDIOINPUTS];
-  static int OutClip[ECHO_MAXAUDIOOUTPUTS];
-  char str[8];
-  int i, o, dB;
-  GdkColor Grid={0x787878, 0, 0, 0};
-  GdkColor Labels={0x9694C4, 0, 0, 0};
-  GdkColor Hilight={0x000078, 0, 0, 0};
-  GdkColor Hilight2={0x600000, 0, 0, 0};
+    cairo_t *cr;
+    int InLevel[ECHO_MAXAUDIOINPUTS];
+    int InPeak[ECHO_MAXAUDIOINPUTS];
+    int OutLevel[ECHO_MAXAUDIOOUTPUTS];
+    int OutPeak[ECHO_MAXAUDIOOUTPUTS];
+    int VirLevel[ECHO_MAXAUDIOOUTPUTS];
+    int VirPeak[ECHO_MAXAUDIOOUTPUTS];
+    static int InClip[ECHO_MAXAUDIOINPUTS];
+    static int OutClip[ECHO_MAXAUDIOOUTPUTS];
+    char str[8];
+    int i, o, dB;
+
+    if (!Mixpixmap)
+        return TRUE;
+
+    GetVUmeters(InLevel, InPeak, OutLevel, OutPeak, VirLevel, VirPeak);
+
+    GdkWindow *window = gtk_widget_get_window(Mixdarea);
+    if (!window)
+        return TRUE;
+
+    cr = gdk_cairo_create(window);
+
+    // Clear the background to black
+    cairo_set_source_rgb(cr, 0, 0, 0);
+    cairo_rectangle(cr, 0, 0, Mixwidth, Mixheight);
+    cairo_fill(cr);
+
+    // Highlight
+    cairo_set_source_rgb(cr, 0, 0, 0.47);
+    cairo_rectangle(cr, 0, YCELLTOT * mixerControl.input, Mixwidth, YCELLTOT);
+    cairo_fill(cr);
 
-  if (!Mixpixmap)
-    return(TRUE);
+    if (vmixerId) {
+        cairo_set_source_rgb(cr, 0.38, 0, 0);
+        cairo_rectangle(cr, 0, YCELLTOT * (GMixerSection.VmixerFirst + vmixerControl.input), Mixwidth, YCELLTOT);
+        cairo_fill(cr);
+    }
 
-  update_rect.x = 0;
-  update_rect.y = 0;
-  update_rect.width = Mixwidth;
-  update_rect.height = Mixheight;
-  GetVUmeters(InLevel, InPeak, OutLevel, OutPeak, VirLevel, VirPeak);
-
-  if (!gc) {
-    gc=gdk_gc_new(gtk_widget_get_parent_window(Mixdarea));
-    for (i=0; i<nIn; i++)
-      InClip[i]=0;
-    for (i=0; i<nLOut; i++)
-      OutClip[i]=0;
-  }
-
-  gdk_draw_rectangle(Mixpixmap, Mixdarea->style->black_gc, TRUE, 0, 0, Mixwidth, Mixheight);
-
-  // Highlight
-  gdk_gc_set_foreground(gc, &Hilight);
-  gdk_draw_rectangle(Mixpixmap, gc, TRUE, 0, YCELLTOT*mixerControl.input, XCELLTOT*(mixerControl.output+1), YCELLTOT);
-  gdk_draw_rectangle(Mixpixmap, gc, TRUE, XCELLTOT*(mixerControl.output+1), YCELLTOT*mixerControl.input, XCELLTOT, Mixheight);
-  if (vmixerId) {
-    gdk_gc_set_foreground(gc, &Hilight2);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, 0, YCELLTOT*(GMixerSection.VmixerFirst+vmixerControl.input), XCELLTOT*(vmixerControl.output+1), YCELLTOT);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, XCELLTOT*(vmixerControl.output+1), YCELLTOT*(GMixerSection.VmixerFirst+vmixerControl.input), XCELLTOT, Mixheight);
-  }
-
-  // Draw the grid
-
-  gdk_gc_set_font(gc, fnt);
-  // Horizontal lines and input channel labels
-  for (i=0; i<GMixerSection.LineOut; i++) {
-    gdk_gc_set_foreground(gc, &Grid);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, 0, YCELLTOT*(i+1)-1, Mixwidth, 1);
-    if (i<fdIn)
-      sprintf(str, "A%d", i);		// Analog
-    else if (i<nIn)
-      sprintf(str, "D%d", i-fdIn);	// Digital
-    else
-      sprintf(str, "V%d", i-nIn);	// Virtual
-    gdk_gc_set_foreground(gc, &Labels);
-    gdk_draw_string(Mixpixmap, fnt, gc, 1, YCELLTOT*i+(YCELLTOT/2)+4, str);
-  }
-
-  // Vertical lines and output channel labels
-  for (o=0; o<nLOut; o++) {
-    gdk_gc_set_foreground(gc, &Grid);
-    gdk_draw_rectangle(Mixpixmap, gc, TRUE, XCELLTOT*(o+1), 0, 1, Mixheight);
-    if (o<fdOut)
-      sprintf(str, "A%d", o);
-    else
-      sprintf(str, "D%d", o-fdOut);
-    gdk_gc_set_foreground(gc, &Labels);
-    gdk_draw_string(Mixpixmap, fnt, gc, XCELLTOT*(o+1)+(XCELLTOT/2)-6, YCELLTOT*GMixerSection.LineOut+YCELLTOT+8, str);
-  }
-  gdk_draw_string(Mixpixmap, fnt, gc, 1, 8, "In");
-  gdk_draw_string(Mixpixmap, fnt, gc, 1, YCELLTOT*GMixerSection.LineOut+YCELLTOT+8, "Out");
-  gdk_gc_set_foreground(gc, &Grid);
-  gdk_draw_rectangle(Mixpixmap, gc, TRUE, 0, YCELLTOT*(GMixerSection.LineOut+1)-1, Mixwidth, 1);
-
-  // Draw input levels and peaks
-  for (i=0; i<GMixerSection.Inputs; i++)
-    DrawBar(0, i, InLevel[i], InPeak[i], DONT_DRAW);
+    // Draw the grid and labels
+    for (i = 0; i < GMixerSection.LineOut; i++) {
+        cairo_set_source_rgb(cr, 0.47, 0.47, 0.47);
+        cairo_move_to(cr, 0, YCELLTOT * (i + 1) - 1);
+        cairo_line_to(cr, Mixwidth, YCELLTOT * (i + 1) - 1);
+        cairo_stroke(cr);
+    }
 
-  // Draw vchannels levels and peaks (Vmixer cards only)
-  if (vmixerId) {
-    for (i=0; i<vmixerControl.inputs; i++)
-      DrawBar(0, i+GMixerSection.VmixerFirst, VirLevel[i], VirPeak[i], DONT_DRAW);
-  }
+    for (o = 0; o < nLOut; o++) {
+        cairo_move_to(cr, XCELLTOT * (o + 1), 0);
+        cairo_line_to(cr, XCELLTOT * (o + 1), Mixheight);
+        cairo_stroke(cr);
+    }
 
-  // Draw output levels, peaks and volumes
-  for (o=0; o<GMixerSection.Outputs; o++)
-    DrawBar(o+1, GMixerSection.LineOut, OutLevel[o], OutPeak[o], lineoutControl.Gain[o]);
+    // Draw input levels and peaks
+    for (i = 0; i < GMixerSection.Inputs; i++)
+        DrawBar(0, i, InLevel[i], InPeak[i], DONT_DRAW);
 
-  // Draw monitor mixer elements
-  for (o=0; o<GMixerSection.Outputs; o++) {
-    for (i=0; i<GMixerSection.Inputs; i++) {
-      dB=Add_dB(mixerControl.mixer[o][i].Gain, InLevel[i]);
-      DrawBar(o+1, i, dB, DONT_DRAW, mixerControl.mixer[o][i].Gain);
+    if (vmixerId) {
+        for (i = 0; i < vmixerControl.inputs; i++)
+            DrawBar(0, i + GMixerSection.VmixerFirst, VirLevel[i], VirPeak[i], DONT_DRAW);
     }
-  }
 
-  // Draw vmixer elements (Vmixer cards only)
-  if (vmixerId) {
-    for (o=0; o<GMixerSection.Outputs; o++)
-      for (i=0; i<vmixerControl.inputs; i++) {
-        dB=Add_dB(vmixerControl.mixer[o][i].Gain, VirLevel[i]);
-        DrawBar(o+1, i+GMixerSection.VmixerFirst, dB, DONT_DRAW, vmixerControl.mixer[o][i].Gain);
-      }
-  }
+    for (o = 0; o < GMixerSection.Outputs; o++)
+        DrawBar(o + 1, GMixerSection.LineOut, OutLevel[o], OutPeak[o], lineoutControl.Gain[o]);
 
-  gtk_widget_draw(Mixdarea, &update_rect);
-  return(TRUE);
-}
+    for (o = 0; o < GMixerSection.Outputs; o++) {
+        for (i = 0; i < GMixerSection.Inputs; i++) {
+            dB = Add_dB(mixerControl.mixer[o][i].Gain, InLevel[i]);
+            DrawBar(o + 1, i, dB, DONT_DRAW, mixerControl.mixer[o][i].Gain);
+        }
+    }
 
+    if (vmixerId) {
+        for (o = 0; o < GMixerSection.Outputs; o++)
+            for (i = 0; i < vmixerControl.inputs; i++) {
+                dB = Add_dB(vmixerControl.mixer[o][i].Gain, VirLevel[i]);
+                DrawBar(o + 1, i + GMixerSection.VmixerFirst, dB, DONT_DRAW, vmixerControl.mixer[o][i].Gain);
+            }
+    }
 
+    cairo_destroy(cr);
+    return TRUE;
+}
 
 // Draw the VU-meter
 gint DrawVUmeters(gpointer unused) {
-  GdkRectangle update_rect;
-  int InLevel[ECHO_MAXAUDIOINPUTS];
-  int InPeak[ECHO_MAXAUDIOINPUTS];
-  int OutLevel[ECHO_MAXAUDIOOUTPUTS];
-  int OutPeak[ECHO_MAXAUDIOOUTPUTS];
-  int VirLevel[ECHO_MAXAUDIOOUTPUTS];
-  int VirPeak[ECHO_MAXAUDIOOUTPUTS];
-  static int InClip[ECHO_MAXAUDIOINPUTS];
-  static int OutClip[ECHO_MAXAUDIOOUTPUTS];
-  int i, x, dB;
-  char str[16];
-  GdkColor Selected={0xC86060, 0, 0, 0};
-  GdkColor Grid={0x9694C4, 0, 0, 0};
-  GdkColor Grid2={0x646383, 0, 0, 0};
-  GdkColor dBValues={0x00B000, 0, 0, 0};
-  GdkColor AnBars={0x00E0B8, 0, 0, 0};
-  GdkColor DiBars={0x98E000, 0, 0, 0};
-  GdkColor ClipPeak={0, 0, 0, 0};
-  GdkColor Peak={0x00FF00, 0, 0, 0};
-
-  if (!VUpixmap)
-    return(TRUE);
+    GdkRectangle update_rect;
+    int InLevel[ECHO_MAXAUDIOINPUTS];
+    int InPeak[ECHO_MAXAUDIOINPUTS];
+    int OutLevel[ECHO_MAXAUDIOOUTPUTS];
+    int OutPeak[ECHO_MAXAUDIOOUTPUTS];
+    int VirLevel[ECHO_MAXAUDIOOUTPUTS];
+    int VirPeak[ECHO_MAXAUDIOOUTPUTS];
+    static int InClip[ECHO_MAXAUDIOINPUTS];
+    static int OutClip[ECHO_MAXAUDIOOUTPUTS];
+    int i, x, dB;
+    char str[16];
+    GdkRGBA Selected = {0xC8 / 255.0, 0, 0, 1};
+    GdkRGBA Grid = {0x96 / 255.0, 0x94 / 255.0, 0xC4 / 255.0, 1};
+    GdkRGBA Grid2 = {0x64 / 255.0, 0x63 / 255.0, 0x83 / 255.0, 1};
+    GdkRGBA dBValues = {0, 0.69, 0, 1};
+    GdkRGBA AnBars = {0, 0.88, 0.72, 1};
+    GdkRGBA DiBars = {0.60, 0.88, 0, 1};
+    GdkRGBA ClipPeak = {0, 0, 0, 0};
+    GdkRGBA Peak = {0, 1, 0, 1};
+
+    if (!VUpixmap)
+        return TRUE;
+
+    update_rect.x = 0;
+    update_rect.y = 0;
+    update_rect.width = VUwidth;
+    update_rect.height = VUheight;
+    GetVUmeters(InLevel, InPeak, OutLevel, OutPeak, VirLevel, VirPeak);
+
+    if (!cr) { // Cairo context
+        cr = gdk_cairo_create(gtk_widget_get_window(VUdarea));
+        for (i = 0; i < nIn; i++)
+            InClip[i] = 0;
+        for (i = 0; i < nLOut; i++)
+            OutClip[i] = 0;
+    }
+
+    // Clear the image
+    cairo_set_source_rgba(cr, 0, 0, 0, 1);
+    cairo_paint(cr);
+
+    // Draw the dB scale and the grid
+//    cairo_set_font_face(cr, font_face);
+//    cairo_set_font_size(cr, font_size);
+    // Set font (ensure it's defined)
+//    cairo_select_font_face(cr, fnt, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
+//    cairo_set_font_size(cr, font_size);
+    PangoLayout *layout = gtk_widget_create_pango_layout(VUdarea, NULL);
+    pango_layout_set_font_description(layout, fnt);
+
+    cairo_set_source_rgba(cr, Peak.red, Peak.green, Peak.blue, 1);
+    cairo_move_to(cr, 2, VU_YGRAF - 12 + 4);
+    cairo_show_text(cr, "  dB");
+
+    for (i = 0; i <= 120; i += 12) {
+        sprintf(str, "%4d", -i);
+        cairo_set_source_rgba(cr, dBValues.red, dBValues.green, dBValues.blue, 1);
+        cairo_move_to(cr, 2, VU_YGRAF + i + 4);
+        cairo_show_text(cr, str);
+        cairo_set_source_rgba(cr, Grid.red, Grid.green, Grid.blue, 1);
+        cairo_rectangle(cr, VU_XGRAF, VU_YGRAF + i, VUwidth - VU_XGRAF, 1);
+        cairo_fill(cr);
+    }
+
+    cairo_set_source_rgba(cr, Grid2.red, Grid2.green, Grid2.blue, 1);
+    cairo_rectangle(cr, VU_XGRAF, VU_YGRAF + 128, VUwidth - VU_XGRAF, 1);
+    cairo_fill(cr);
+
+    x = VU_XGRAF + VU_BARSEP;
+
+    // Draw inputs
+    for (i = 0; i < nIn; i++) {
+        if (i < fdIn)
+            cairo_set_source_rgba(cr, AnBars.red, AnBars.green, AnBars.blue, 1);
+        else
+            cairo_set_source_rgba(cr, DiBars.red, DiBars.green, DiBars.blue, 1);
+
+        dB = InLevel[i];
+        cairo_rectangle(cr, x, VU_YGRAF - dB, VU_BARWIDTH, 129 + VU_YGRAF - (VU_YGRAF - dB));
+        cairo_fill(cr);
+
+        dB = InPeak[i];
+        if (dB == 0)
+            InClip[i] = 64;
+        if (InClip[i]) {
+            InClip[i]--;
+            ClipPeak.red = (InClip[i] << 18) / 255.0;
+            ClipPeak.green = (255 - (InClip[i] * 3)) / 255.0;
+            cairo_set_source_rgba(cr, ClipPeak.red, ClipPeak.green, ClipPeak.blue, 1);
+        } else {
+            cairo_set_source_rgba(cr, Peak.red, Peak.green, Peak.blue, 1);
+        }
 
-  update_rect.x = 0;
-  update_rect.y = 0;
-  update_rect.width = VUwidth;
-  update_rect.height = VUheight;
-  GetVUmeters(InLevel, InPeak, OutLevel, OutPeak, VirLevel, VirPeak);
-
-  if (!gc) {
-    gc=gdk_gc_new(gtk_widget_get_parent_window(VUdarea));
-    for (i=0; i<nIn; i++)
-      InClip[i]=0;
-    for (i=0; i<nLOut; i++)
-      OutClip[i]=0;
-  }
-
-  // Clear the image
-  gdk_draw_rectangle(VUpixmap, VUdarea->style->black_gc, TRUE, 0, 0, VUwidth, VUheight);
-
-  // Draw the dB scale and the grid
-  gdk_gc_set_font(gc, fnt);
-  gdk_gc_set_foreground(gc, &Peak);
-  gdk_draw_string(VUpixmap, fnt, gc, 2, VU_YGRAF-12+4, "  dB");
-  for (i=0; i<=120; i+=12) {
-    sprintf(str, "%4d", -i);
-    gdk_gc_set_foreground(gc, &dBValues);
-    gdk_draw_string(VUpixmap, fnt, gc, 2, VU_YGRAF+i+4, str);
-    gdk_gc_set_foreground(gc, &Grid);
-    gdk_draw_rectangle(VUpixmap, gc, TRUE, VU_XGRAF, VU_YGRAF+i, VUwidth-VU_XGRAF, 1);
-  }
-  gdk_gc_set_foreground(gc, &Grid2);
-  gdk_draw_rectangle(VUpixmap, gc, TRUE, VU_XGRAF, VU_YGRAF+128, VUwidth-VU_XGRAF, 1);
+        cairo_rectangle(cr, x, VU_YGRAF - dB, VU_BARWIDTH, 1);
+        cairo_fill(cr);
 
-  x=VU_XGRAF+VU_BARSEP;
+        if (mixerControl.input == i) {
+            cairo_set_source_rgba(cr, Selected.red, Selected.green, Selected.blue, 1);
+            cairo_rectangle(cr, x + 1, VU_YGRAF + 128 + 3, VU_BARWIDTH - 2, 1);
+            cairo_fill(cr);
+            cairo_rectangle(cr, x, VU_YGRAF + 128 + 4, VU_BARWIDTH, 1);
+            cairo_fill(cr);
+        }
 
-  // Draw inputs
-  for (i=0; i<nIn; i++) {
-    if (i<fdIn)
-      gdk_gc_set_foreground(gc, &AnBars);
-    else
-      gdk_gc_set_foreground(gc, &DiBars);
-    dB=InLevel[i];
-    gdk_draw_rectangle(VUpixmap, gc, TRUE, x, VU_YGRAF-dB, VU_BARWIDTH, 129+VU_YGRAF-(VU_YGRAF-dB));
-
-    dB=InPeak[i];
-    if (dB==0)
-      InClip[i]=64;
-    if (InClip[i]) {
-      InClip[i]--;
-      ClipPeak.pixel=(InClip[i]<<18)+((255-(InClip[i]*3))<<8);
-      gdk_gc_set_foreground(gc, &ClipPeak);
-    } else {
-      gdk_gc_set_foreground(gc, &Peak);
-    }
-    gdk_draw_rectangle(VUpixmap, gc, TRUE, x, VU_YGRAF-dB, VU_BARWIDTH, 1);
-    if (mixerControl.input==i) {
-      gdk_gc_set_foreground(gc, &Selected);
-      gdk_draw_rectangle(VUpixmap, gc, TRUE, x+1, VU_YGRAF+128+3, VU_BARWIDTH-2, 1);
-      gdk_draw_rectangle(VUpixmap, gc, TRUE, x, VU_YGRAF+128+4, VU_BARWIDTH, 1);
+        x += VU_BARWIDTH + VU_BARSEP;
     }
-    x+=VU_BARWIDTH+VU_BARSEP;
-  }
 
-  // Draw outputs
-  x+=VU_BARWIDTH+VU_BARSEP;
-  for (i=0; i<nLOut; i++) {
-    if (i<fdOut)
-      gdk_gc_set_foreground(gc, &AnBars);
-    else
-      gdk_gc_set_foreground(gc, &DiBars);
-    dB=OutLevel[i];
-    gdk_draw_rectangle(VUpixmap, gc, TRUE, x, VU_YGRAF-dB, VU_BARWIDTH, 129+VU_YGRAF-(VU_YGRAF-dB));
-
-    dB=OutPeak[i];
-    if (dB==0)
-      OutClip[i]=64;
-    if (OutClip[i]) {
-      OutClip[i]--;
-      ClipPeak.pixel=(OutClip[i]<<18)+((255-(OutClip[i]*3))<<8);
-      gdk_gc_set_foreground(gc, &ClipPeak);
-    } else {
-      gdk_gc_set_foreground(gc, &Peak);
-    }
-    gdk_draw_rectangle(VUpixmap, gc, TRUE, x, VU_YGRAF-dB, VU_BARWIDTH, 1);
-    if (mixerControl.output==i) {
-      gdk_gc_set_foreground(gc, &Selected);
-      gdk_draw_rectangle(VUpixmap, gc, TRUE, x+1, VU_YGRAF+128+3, VU_BARWIDTH-2, 1);
-      gdk_draw_rectangle(VUpixmap, gc, TRUE, x, VU_YGRAF+128+4, VU_BARWIDTH, 1);
+    // Draw outputs
+    x += VU_BARWIDTH + VU_BARSEP;
+    for (i = 0; i < nLOut; i++) {
+        if (i < fdOut)
+            cairo_set_source_rgba(cr, AnBars.red, AnBars.green, AnBars.blue, 1);
+        else
+            cairo_set_source_rgba(cr, DiBars.red, DiBars.green, DiBars.blue, 1);
+
+        dB = OutLevel[i];
+        cairo_rectangle(cr, x, VU_YGRAF - dB, VU_BARWIDTH, 129 + VU_YGRAF - (VU_YGRAF - dB));
+        cairo_fill(cr);
+
+        dB = OutPeak[i];
+        if (dB == 0)
+            OutClip[i] = 64;
+        if (OutClip[i]) {
+            OutClip[i]--;
+            ClipPeak.red = (OutClip[i] << 18) / 255.0;
+            ClipPeak.green = (255 - (OutClip[i] * 3)) / 255.0;
+            cairo_set_source_rgba(cr, ClipPeak.red, ClipPeak.green, ClipPeak.blue, 1);
+        } else {
+            cairo_set_source_rgba(cr, Peak.red, Peak.green, Peak.blue, 1);
+        }
+
+        cairo_rectangle(cr, x, VU_YGRAF - dB, VU_BARWIDTH, 1);
+        cairo_fill(cr);
+
+        if (mixerControl.output == i) {
+            cairo_set_source_rgba(cr, Selected.red, Selected.green, Selected.blue, 1);
+            cairo_rectangle(cr, x + 1, VU_YGRAF + 128 + 3, VU_BARWIDTH - 2, 1);
+            cairo_fill(cr);
+            cairo_rectangle(cr, x, VU_YGRAF + 128 + 4, VU_BARWIDTH, 1);
+            cairo_fill(cr);
+        }
+
+        x += VU_BARWIDTH + VU_BARSEP;
     }
-    x+=VU_BARWIDTH+VU_BARSEP;
-  }
 
-  gtk_widget_draw(VUdarea, &update_rect);
+    // Update the widget
+    gtk_widget_queue_draw_area(VUdarea, update_rect.x, update_rect.y, update_rect.width, update_rect.height);
 
-  return(TRUE);
+    return TRUE;
 }
 
 
@@ -1047,7 +1113,8 @@
   char str[16];
 
   UI_DEBUG(("Monitor_volume_changed()  %d %d\n",mixerControl.input,mixerControl.output));
-  val=rval=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+//  val=rval=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+  val = rval = INVERT((int)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
 
   ch=(int)(long)cnl;
 
@@ -1110,13 +1177,15 @@
     // Input
     channel=(int)(long)ch;
     vol=&lineinControl;
-    rval=val=IN_INVERT((int)GTK_ADJUSTMENT(widget)->value);
+//    rval=val=IN_INVERT((int)GTK_ADJUSTMENT(widget)->value);
+	rval = val = IN_INVERT((int)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
     sprintf(str, "%+4.1f", 0.5*val);
   } else {
     // Output
     channel=(int)(long)ch-ECHO_MAXAUDIOINPUTS;
     vol=&pcmoutControl;
-    val=rval=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+//    val=rval=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+	val = rval = INVERT((int)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
     pcmoutControl.Gain[channel]=val;
     // Emulate the line-out volume if this card can't do it in hw.
     if (!lineoutId) {
@@ -1144,7 +1213,8 @@
     vol->Gain[channel]=val;
   }
   if (Gang)
-    gtk_adjustment_set_value(GTK_ADJUSTMENT(vol->adj[channel^1]), (gfloat)GTK_ADJUSTMENT(widget)->value);
+//    gtk_adjustment_set_value(GTK_ADJUSTMENT(vol->adj[channel^1]), (gfloat)GTK_ADJUSTMENT(widget)->value);
+	gtk_adjustment_set_value(vol->adj[channel^1], (gfloat)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
 }
 
 
@@ -1226,7 +1296,9 @@
 
   channel=(int)(long)ch;
 
-  val=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+//  val=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+  val = INVERT((int)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
+
   lineoutControl.Gain[channel]=val;
 
   gtk_label_set_text(GTK_LABEL(lineoutControl.label[channel]), strOutGain(str, val));
@@ -1255,7 +1327,8 @@
   }
 
   if (Gang)
-    gtk_adjustment_set_value(GTK_ADJUSTMENT(lineoutControl.adj[channel^1]), (gfloat)GTK_ADJUSTMENT(widget)->value);
+//    gtk_adjustment_set_value(GTK_ADJUSTMENT(lineoutControl.adj[channel^1]), (gfloat)GTK_ADJUSTMENT(widget)->value);
+	gtk_adjustment_set_value(lineoutControl.adj[channel^1], (gfloat)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
 }
 
 
@@ -1266,7 +1339,8 @@
   int o, v;
 
   channel=(int)(long)ch;
-  val=rval=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+//  val=rval=INVERT((int)GTK_ADJUSTMENT(widget)->value);
+  val = rval = INVERT((int)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget)));
 
 #ifdef REVERSE
   v=channel;
@@ -1289,7 +1363,7 @@
     SetMixerGain(&vmixerControl.mixer[o^1][v^1], rval);
     vmixerControl.mixer[o^1][v^1].Gain=val;
   }
-  
+
   gtk_label_set_text(GTK_LABEL(vmixerControl.label[channel]), strOutGain(str, val));
 }
 
@@ -1325,7 +1399,8 @@
   snd_ctl_elem_id_set_interface(id, SND_CTL_ELEM_IFACE_MIXER);
   for (c=vmixerControl.inputs-1; c>=0; c--) {
     val=INVERT(vmixerControl.mixer[vmixerControl.output][c].Gain);
-    gtk_adjustment_set_value(GTK_ADJUSTMENT(vmixerControl.adj[c]), (gfloat)val);
+//    gtk_adjustment_set_value(GTK_ADJUSTMENT(vmixerControl.adj[c]), (gfloat)val);
+    gtk_adjustment_set_value(vmixerControl.adj[c], (gfloat)val);
   }
 }
 
@@ -1346,7 +1421,8 @@
   snd_ctl_elem_id_set_interface(id, SND_CTL_ELEM_IFACE_MIXER);
   for (c=vmixerControl.outputs-1; c>=0; c--) {
     val=INVERT(vmixerControl.mixer[c][vmixerControl.input].Gain);
-    gtk_adjustment_set_value(GTK_ADJUSTMENT(vmixerControl.adj[c]), (gfloat)val);
+//    gtk_adjustment_set_value(GTK_ADJUSTMENT(vmixerControl.adj[c]), (gfloat)val);
+    gtk_adjustment_set_value(vmixerControl.adj[c], (gfloat)val);
   }
 }
 
@@ -1406,37 +1482,38 @@
 }
 
 
-
 void AutoClock_toggled(GtkWidget *widget, gpointer unused) {
   char str[32];
 
   if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) {
-    AutoClock=clocksrcVal;
-    snprintf(str, 31, "Autoclock [%s]", clocksrcName[AutoClock]);
-    str[31]=0;
-    gtk_label_set_text(GTK_LABEL(GTK_BIN(widget)->child), str);
+    AutoClock = clocksrcVal;
+    snprintf(str, sizeof(str), "Autoclock [%s]", clocksrcName[AutoClock]);
+    str[sizeof(str)-1] = '\0';  // Ensure null termination
+//	gtk_label_set_text(GTK_LABEL(GTK_BIN(widget)->child), str);
+    gtk_label_set_text(GTK_LABEL(gtk_bin_get_child(GTK_BIN(widget))), str);
   } else {
-    AutoClock=-1;
-    gtk_label_set_text(GTK_LABEL(GTK_BIN(widget)->child), "Autoclock");
+    AutoClock = -1;
+//	gtk_label_set_text(GTK_LABEL(GTK_BIN(widget)->child), "Autoclock");
+    gtk_label_set_text(GTK_LABEL(gtk_bin_get_child(GTK_BIN(widget))), "Autoclock");
   }
-
 }
 
 
-
 void Digital_mode_activate(GtkWidget *widget, gpointer mode) {
   int adat;
 
   if (SetEnum(dmodeId, (int)(long)mode)<0) {
     // Restore old value if it failed
-    gtk_option_menu_set_history(GTK_OPTION_MENU(dmodeOpt), dmodeVal);
+//    gtk_option_menu_set_history(GTK_COMBO_BOX(dmodeOpt), dmodeVal);
+	gtk_combo_box_set_active(GTK_COMBO_BOX(dmodeOpt), dmodeVal);
     return;
   }
 
   dmodeVal=(int)(long)mode;
   // When I change the digital mode, the clock source can change too
   clocksrcVal=GetEnum(clocksrcId);
-  gtk_option_menu_set_history(GTK_OPTION_MENU(clocksrcOpt), clocksrcVal);
+//  gtk_option_menu_set_history(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal);
+  gtk_combo_box_set_active(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal);
 
   adat=!memcmp(dmodeName[dmodeVal], "ADAT", 4);
   SetSensitivity(adat);
@@ -1456,7 +1533,8 @@
 
   source=(unsigned int)(long)clk & 0xff;
   if (SetEnum(clocksrcId, source)<0) {
-    gtk_option_menu_set_history(GTK_OPTION_MENU(clocksrcOpt), clocksrcVal);
+//    gtk_option_menu_set_history(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal);
+    gtk_combo_box_set_active(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal);
   } else {
     clocksrcVal=(int)(long)clk & 0xff;
     // Change only when the user triggers it
@@ -1478,18 +1556,47 @@
 
 
 // Create a new backing pixmap of the appropriate size
+/*
 static gint VU_configure_event(GtkWidget *widget, GdkEventConfigure *event) {
-
   if (VUpixmap)
     gdk_pixmap_unref(VUpixmap);
   VUpixmap=gdk_pixmap_new(widget->window, widget->allocation.width, widget->allocation.height, -1);
   gdk_draw_rectangle(VUpixmap, widget->style->black_gc, TRUE, 0, 0, widget->allocation.width, widget->allocation.height);
   return(TRUE);
+}*/
+static gint VU_configure_event(GtkWidget *widget, GdkEventConfigure *event) {
+    // Release the previous surface if it exists
+    if (VUpixmap)
+        cairo_surface_destroy(VUpixmap); // Destroy the Cairo surface
+
+    // Create a Cairo context for drawing
+    cairo_t *cr = cairo_create(VUpixmap);
+
+    // Set a background color (black in this case)
+    cairo_set_source_rgb(cr, 0, 0, 0); // Black color
+    // Get the widget's allocation (position and size)
+    GtkAllocation allocation;
+    gtk_widget_get_allocation(widget, &allocation);
+    // Create a new Cairo surface for the widget
+    cairo_set_source_surface(
+		cr,
+		VUpixmap,
+        allocation.width,                        // Width of the widget
+        allocation.height                       // Height of the widget
+    );
+
+    cairo_paint(cr); // Fill the surface with the black color
+
+    // Clean up the Cairo context
+    cairo_destroy(cr);
+
+    return TRUE;
 }
 
 
 
 // Redraw the screen from the backing pixmap
+ /*
 static gint VU_expose(GtkWidget *widget, GdkEventExpose *event) {
 
   if (VUpixmap)
@@ -1498,11 +1605,31 @@
                     event->area.x, event->area.y,
                     event->area.width, event->area.height);
   return(FALSE);
-}
+}*/
+// Redraw the screen from the backing surface (pixmap equivalent)
+static gint VU_expose(GtkWidget *widget, GdkEventExpose *event) {
+    GdkWindow *window = gtk_widget_get_window(widget);
+
+    if (VUpixmap) {
+        // Create a cairo context for the widget's window
+        cr = cairo_create(VUpixmap);
 
+        // Set the source surface to VUpixmap (this is the backing surface)
+        cairo_set_source_surface(cr, VUpixmap, event->area.x, event->area.y);
+
+        // Paint the surface onto the widget's window
+        cairo_paint(cr);
+
+        // Clean up the cairo context
+        cairo_destroy(cr);
+    }
+
+    return FALSE;
+}
 
 
 // Create a new backing pixmap of the appropriate size
+/*
 static gint Gmixer_configure_event(GtkWidget *widget, GdkEventConfigure *event) {
 
   if (Mixpixmap)
@@ -1510,30 +1637,81 @@
   Mixpixmap=gdk_pixmap_new(widget->window, widget->allocation.width, widget->allocation.height, -1);
   gdk_draw_rectangle(Mixpixmap, widget->style->black_gc, TRUE, 0, 0, widget->allocation.width, widget->allocation.height);
   return(TRUE);
-}
+}*/
+// Create a new backing surface of the appropriate size
+static gint Gmixer_configure_event(GtkWidget *widget, GdkEventConfigure *event) {
+    // Release the previous surface if it exists
+    if (Mixpixmap)
+        cairo_surface_destroy(Mixpixmap); // Destroy the Cairo surface
+
+    // Create a Cairo context for drawing
+    cairo_t *cr = cairo_create(Mixpixmap);
+
+    // Set a background color (black in this case)
+    cairo_set_source_rgb(cr, 0, 0, 0); // Black color
+    // Get the widget's allocation (position and size)
+    GtkAllocation allocation;
+    gtk_widget_get_allocation(widget, &allocation);
+    // Create a new Cairo surface for the widget
+    cairo_set_source_surface(
+		cr,
+		Mixpixmap,
+        allocation.width,                        // Width of the widget
+        allocation.height                       // Height of the widget
+    );
 
+    cairo_paint(cr); // Fill the surface with the black color
 
+    // Clean up the Cairo context
+    cairo_destroy(cr);
+
+    return TRUE;
+}
 
 // Redraw the screen from the backing pixmap
+/*
 static gint Gmixer_expose(GtkWidget *widget, GdkEventExpose *event) {
-
   if (Mixpixmap)
     gdk_draw_pixmap(widget->window, widget->style->fg_gc[GTK_WIDGET_STATE(widget)], Mixpixmap,
                     event->area.x, event->area.y,
                     event->area.x, event->area.y,
                     event->area.width, event->area.height);
   return(FALSE);
+}*/
+// Redraw the screen from the backing surface (cairo equivalent to pixmap)
+static gint Gmixer_expose(GtkWidget *widget, GdkEventExpose *event) {
+    GdkWindow *window = gtk_widget_get_window(widget);
+
+    if (Mixpixmap) {
+        // Create a cairo context for the widget's window
+        cr = cairo_create(Mixpixmap);
+
+        // Set the source surface to Mixpixmap (this is the backing surface)
+        cairo_set_source_surface(cr, Mixpixmap, event->area.x, event->area.y);
+
+        // Paint the surface onto the widget's window
+        cairo_paint(cr);
+
+        // Clean up the cairo context
+        cairo_destroy(cr);
+    }
+
+    return FALSE;
 }
 
 
 
+
 gint CloseWindow(GtkWidget *widget, GdkEvent *event, gpointer geom) {
   struct geometry *g=geom;
 
-  gdk_window_get_root_origin(widget->window, &g->x, &g->y);
-  gdk_window_get_size(widget->window, &g->w, &g->h);
+  //gdk_window_get_root_origin(widget->window, &g->x, &g->y);
+  //gdk_window_get_size(widget->window, &g->w, &g->h);
+  gdk_window_get_root_origin(gtk_widget_get_window(widget), &g->x, &g->y);
+  gtk_window_get_size(GTK_WINDOW(widget), &g->w, &g->h);
   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->toggler), FALSE);	// This hides the window
   //gtk_widget_set_uposition(widget, g->x, g->y);
+  gtk_window_move(GTK_WINDOW(widget), g->x, g->y);
   return(TRUE);		// Do not destroy it
 }
 
@@ -1543,14 +1721,17 @@
   struct geometry *g=geom;
 
   if (VUwindow) {
-    gdk_window_get_root_origin(VUwindow->window, &VUw_geom.x, &VUw_geom.y);
+    //gdk_window_get_root_origin(VUwindow->window, &VUw_geom.x, &VUw_geom.y);
+    gdk_window_get_root_origin(gtk_widget_get_window(VUwindow), &VUw_geom.x, &VUw_geom.y);
     gtk_widget_destroy(VUwindow);
   }
   if (GMwindow) {
-    gdk_window_get_root_origin(GMwindow->window, &GMw_geom.x, &GMw_geom.y);
+    //gdk_window_get_root_origin(GMwindow->window, &GMw_geom.x, &GMw_geom.y);
+    gdk_window_get_root_origin(gtk_widget_get_window(GMwindow), &GMw_geom.x, &GMw_geom.y);
     gtk_widget_destroy(GMwindow);
   }
-  gdk_window_get_root_origin(Mainwindow->window, &g->x, &g->y);
+  //gdk_window_get_root_origin(Mainwindow->window, &g->x, &g->y);
+  gdk_window_get_root_origin(gtk_widget_get_window(Mainwindow), &g->x, &g->y);
   gtk_main_quit();
   return(FALSE);
 }
@@ -1560,7 +1741,8 @@
 gint VUwindow_delete(GtkWidget *widget, GdkEvent *event, gpointer geom) {
   struct geometry *g=geom;
 
-  gdk_window_get_root_origin(widget->window, &g->x, &g->y);
+  //gdk_window_get_root_origin(widget->window, &g->x, &g->y);
+  gdk_window_get_root_origin(gtk_widget_get_window(widget), &g->x, &g->y);
   g->st=0;
   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->toggler), FALSE);
   return(FALSE);
@@ -1571,7 +1753,8 @@
 gint VUwindow_destroy(GtkWidget *widget, gpointer unused) {
 
   SetVUmeters(0);
-  gtk_timeout_remove(VUtimer);
+  //gtk_timeout_remove(VUtimer);
+  g_source_remove(VUtimer);
   //@@@del gc and fnt
   VUwindow=0;
   return(TRUE);
@@ -1582,7 +1765,8 @@
 gint GMwindow_delete(GtkWidget *widget, GdkEvent *event, gpointer geom) {
   struct geometry *g=geom;
 
-  gdk_window_get_root_origin(widget->window, &g->x, &g->y);
+  //gdk_window_get_root_origin(widget->window, &g->x, &g->y);
+  gdk_window_get_root_origin(gtk_widget_get_window(widget), &g->x, &g->y);
   g->st=0;
   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->toggler), FALSE);
   return(FALSE);
@@ -1593,7 +1777,8 @@
 gint GMwindow_destroy(GtkWidget *widget, gpointer unused) {
 
   SetVUmeters(0);
-  gtk_timeout_remove(Mixtimer);
+  //gtk_timeout_remove(Mixtimer);
+  g_source_remove(Mixtimer);
   //@@@del gc and fnt
   GMwindow=0;
   return(TRUE);
@@ -1616,23 +1801,33 @@
     sprintf(str, "%s VU-meters", cardId);
     gtk_window_set_title (GTK_WINDOW (VUwindow), str);
     gtk_window_set_wmclass(GTK_WINDOW(VUwindow), "vumeters", "Emixer");
-    gtk_signal_connect(GTK_OBJECT(VUwindow), "destroy", GTK_SIGNAL_FUNC(VUwindow_destroy), NULL);
-    gtk_signal_connect(GTK_OBJECT(VUwindow), "delete_event", GTK_SIGNAL_FUNC(VUwindow_delete), (gpointer)&VUw_geom);
-    gtk_window_set_policy(GTK_WINDOW(VUwindow), FALSE, FALSE, TRUE);
+    //gtk_signal_connect(GTK_OBJECT(VUwindow), "destroy", GTK_SIGNAL_FUNC(VUwindow_destroy), NULL);
+    g_signal_connect(VUwindow, "destroy", G_CALLBACK(VUwindow_destroy), NULL);
+    //gtk_signal_connect(GTK_OBJECT(VUwindow), "delete_event", GTK_SIGNAL_FUNC(VUwindow_delete), (gpointer)&VUw_geom);
+    g_signal_connect(VUwindow, "delete_event", G_CALLBACK(VUwindow_delete), (gpointer)&VUw_geom);
+//    gtk_window_set_policy(GTK_WINDOW(VUwindow), FALSE, FALSE, TRUE);
+	gtk_window_set_resizable(GTK_WINDOW(VUwindow), FALSE);  // Disable window resizing
+
     if (VUw_geom.st!=NOPOS)
-      gtk_widget_set_uposition(VUwindow, VUw_geom.x, VUw_geom.y);
+//      gtk_widget_set_uposition(VUwindow, VUw_geom.x, VUw_geom.y);
+      gtk_window_move(GTK_WINDOW(VUwindow), VUw_geom.x, VUw_geom.y);
     gtk_widget_show(VUwindow);
 
     VUdarea=gtk_drawing_area_new();
     gtk_widget_set_events(VUdarea, GDK_EXPOSURE_MASK);
-    gtk_drawing_area_size(GTK_DRAWING_AREA(VUdarea), VUwidth, VUheight);
+//    gtk_drawing_area_size(GTK_DRAWING_AREA(VUdarea), VUwidth, VUheight);
+    gtk_widget_set_size_request(GTK_WIDGET(VUdarea), VUwidth, VUheight);
     gtk_container_add(GTK_CONTAINER(VUwindow), VUdarea);
 
     gtk_widget_show(VUdarea);
-    gtk_signal_connect(GTK_OBJECT(VUdarea), "expose_event", (GtkSignalFunc)VU_expose, NULL);
-    gtk_signal_connect(GTK_OBJECT(VUdarea), "configure_event", (GtkSignalFunc)VU_configure_event, NULL);
-    VUtimer=gtk_timeout_add(30, DrawVUmeters, 0);	// The hw updates the meters about 30 times/s
-    gdk_window_clear_area(VUdarea->window, 0, 0, VUwidth, VUheight);
+    //gtk_signal_connect(GTK_OBJECT(VUdarea), "expose_event", (GtkSignalFunc)VU_expose, NULL);
+    g_signal_connect(VUdarea, "expose_event", G_CALLBACK(VU_expose), NULL);
+    //gtk_signal_connect(GTK_OBJECT(VUdarea), "configure_event", (GtkSignalFunc)VU_configure_event, NULL);
+    g_signal_connect(VUdarea, "configure_event", G_CALLBACK(VU_configure_event), NULL);
+//    VUtimer=gtk_timeout_add(30, DrawVUmeters, 0);	// The hw updates the meters about 30 times/s
+    VUtimer=g_timeout_add(30, DrawVUmeters, 0);	// The hw updates the meters about 30 times/s
+//    gdk_window_clear_area(VUdarea->window, 0, 0, VUwidth, VUheight);
+    gtk_widget_queue_draw(GTK_WIDGET(VUdarea));
     VUw_geom.st=1;
   }
 }
@@ -1654,26 +1849,39 @@
     sprintf(str, "%s Mixer", cardId);
     gtk_window_set_title (GTK_WINDOW (GMwindow), str);
     gtk_window_set_wmclass(GTK_WINDOW(GMwindow), "gridmixer", "Emixer");
-    gtk_signal_connect(GTK_OBJECT(GMwindow), "destroy", GTK_SIGNAL_FUNC(GMwindow_destroy), NULL);
-    gtk_signal_connect(GTK_OBJECT(GMwindow), "delete_event", GTK_SIGNAL_FUNC(GMwindow_delete), (gpointer)&GMw_geom);
-    gtk_window_set_policy(GTK_WINDOW(GMwindow), FALSE, FALSE, TRUE);
+    //gtk_signal_connect(GTK_OBJECT(GMwindow), "destroy", GTK_SIGNAL_FUNC(GMwindow_destroy)), NULL);
+    g_signal_connect(GMwindow, "destroy", G_CALLBACK(GMwindow_destroy), NULL);
+    //gtk_signal_connect(GTK_OBJECT(GMwindow), "delete_event", GTK_SIGNAL_FUNC(GMwindow_delete)), (gpointer)&GMw_geom);
+    g_signal_connect(GMwindow, "delete_event", G_CALLBACK(GMwindow_delete), (gpointer)&GMw_geom);
+//    gtk_window_set_policy(GTK_WINDOW(GMwindow), FALSE, FALSE, TRUE);
+    gtk_window_set_resizable(GTK_WINDOW(GMwindow), FALSE);  // Disable window resizing
     if (GMw_geom.st!=NOPOS)
-      gtk_widget_set_uposition(GMwindow, GMw_geom.x, GMw_geom.y);
+//      gtk_widget_set_uposition(GMwindow, GMw_geom.x, GMw_geom.y);
+        gtk_window_move(GTK_WINDOW(GMwindow), GMw_geom.x, GMw_geom.y);
     gtk_widget_show(GMwindow);
 
     Mixdarea=gtk_drawing_area_new();
     gtk_widget_set_events(Mixdarea, GDK_EXPOSURE_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK);
-    gtk_drawing_area_size(GTK_DRAWING_AREA(Mixdarea), Mixwidth, Mixheight);
+//    gtk_drawing_area_size(GTK_DRAWING_AREA(Mixdarea), Mixwidth, Mixheight);
+    gtk_widget_set_size_request(GTK_WIDGET(Mixdarea), Mixwidth, Mixheight);
     gtk_container_add(GTK_CONTAINER(GMwindow), Mixdarea);
 
     gtk_widget_show(Mixdarea);
-    gtk_signal_connect(GTK_OBJECT(Mixdarea), "expose_event", (GtkSignalFunc)Gmixer_expose, NULL);
-    gtk_signal_connect(GTK_OBJECT(Mixdarea), "configure_event", (GtkSignalFunc)Gmixer_configure_event, NULL);
-    gtk_signal_connect(GTK_OBJECT(Mixdarea), "motion_notify_event", (GtkSignalFunc)Gmixer_motion_notify, NULL);
-    gtk_signal_connect(GTK_OBJECT(Mixdarea), "button_press_event", (GtkSignalFunc)Gmixer_button_press, NULL);
-    gtk_signal_connect(GTK_OBJECT(Mixdarea), "button_release_event", (GtkSignalFunc)Gmixer_button_release, NULL);
-    Mixtimer=gtk_timeout_add(30, DrawMixer, 0);		// The hw updates the meters about 30 times/s
-    gdk_window_clear_area(Mixdarea->window, 0, 0, Mixwidth, Mixheight);
+    //gtk_signal_connect(GTK_OBJECT(Mixdarea), "expose_event", (GtkSignalFunc)Gmixer_expose, NULL);
+    g_signal_connect(Mixdarea, "expose_event", G_CALLBACK(Gmixer_expose), NULL);
+    //gtk_signal_connect(GTK_OBJECT(Mixdarea), "configure_event", (GtkSignalFunc)Gmixer_configure_event, NULL);
+    g_signal_connect(Mixdarea, "configure_event", G_CALLBACK(Gmixer_configure_event), NULL);
+    //gtk_signal_connect(GTK_OBJECT(Mixdarea), "motion_notify_event", (GtkSignalFunc)Gmixer_motion_notify, NULL);
+    g_signal_connect(Mixdarea, "motion_notify_event", G_CALLBACK(Gmixer_motion_notify), NULL);
+    //gtk_signal_connect(GTK_OBJECT(Mixdarea), "button_press_event", (GtkSignalFunc)Gmixer_button_press, NULL);
+    g_signal_connect(Mixdarea, "button_press_event", G_CALLBACK(Gmixer_button_press), NULL);
+    //gtk_signal_connect(GTK_OBJECT(Mixdarea), "button_release_event", (GtkSignalFunc)Gmixer_button_release, NULL);
+    g_signal_connect(Mixdarea, "button_release_event", G_CALLBACK(Gmixer_button_release), NULL);
+//    Mixtimer=gtk_timeout_add(30, DrawMixer, 0);		// The hw updates the meters about 30 times/s
+    Mixtimer=g_timeout_add(30, DrawMixer, 0);		// The hw updates the meters about 30 times/s
+//    gdk_window_clear_area(Mixdarea->window, 0, 0, Mixwidth, Mixheight);
+//    gtk_window_clear_area(gtk_widget_get_window(Mixdarea), 0, 0, Mixwidth, Mixheight);
+    gtk_widget_queue_draw(GTK_WIDGET(Mixdarea));
     GMw_geom.st=1;
   }
 }
@@ -1877,6 +2085,7 @@
   GtkWidget *mainbox;
   GtkWidget *vbsel, *frame, *button;
   GtkWidget *label, *menu, *menuitem;
+  GMenu *gmenu;
   GSList *bgroup;
   int err, i, o, n, cardnum, value;
   char hwname[8], cardname[32], load, save;
@@ -2020,7 +2229,8 @@
     }
   }
   gtk_init(&argc, &argv);
-  fnt=gdk_font_load("-misc-fixed-medium-r-*-*-10-*-*-*-*-*-*-*");
+  //fnt=gdk_font_load("-misc-fixed-medium-r-*-*-10-*-*-*-*-*-*-*");
+  fnt = pango_font_description_from_string("fixed 10");
   if (!fnt) {
     printf("Cannot find the font\n");
     exit(1);
@@ -2035,10 +2245,12 @@
   sprintf(str, "%s Misc controls", cardId);
   gtk_window_set_title(GTK_WINDOW(Miscwindow), str);
   gtk_window_set_wmclass(GTK_WINDOW(Miscwindow), "misc", "Emixer");
-  gtk_signal_connect(GTK_OBJECT(Miscwindow), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&Miscw_geom);
+  //gtk_signal_connect(GTK_OBJECT(Miscwindow), "delete_event", GTK_SIGNAL_FUNC(CloseWindow)), (gpointer)&Miscw_geom);
+  g_signal_connect(Miscwindow, "delete_event", G_CALLBACK(CloseWindow), (gpointer)&Miscw_geom);
   gtk_container_set_border_width(GTK_CONTAINER(Miscwindow), BORDER);
   if (Miscw_geom.st!=NOPOS) {
-    gtk_widget_set_uposition(Miscwindow, Miscw_geom.x, Miscw_geom.y);
+//    gtk_widget_set_uposition(Miscwindow, Miscw_geom.x, Miscw_geom.y);
+    gtk_window_move(GTK_WINDOW(Miscwindow), Miscw_geom.x, Miscw_geom.y);
     gtk_window_set_default_size(GTK_WINDOW(Miscwindow), Miscw_geom.w, Miscw_geom.h);
   }
 
@@ -2062,7 +2274,8 @@
       gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, FALSE, 1);
       gtk_widget_show(button);
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), NominalIn.Level[i]);	// Forces handler call
-      gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(Nominal_level_toggled), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(Nominal_level_toggled)), (gpointer)(long)i);
+	  g_signal_connect(button, "toggled", G_CALLBACK(Nominal_level_toggled), (gpointer)(long)i);
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), !NominalIn.Level[i]);
     }
   }
@@ -2083,7 +2296,8 @@
       gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, FALSE, 1);
       gtk_widget_show(button);
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), NominalOut.Level[i]);
-      gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(Nominal_level_toggled), (gpointer)(long)(i+ECHO_MAXAUDIOINPUTS));
+      //gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(Nominal_level_toggled)), (gpointer)(long)(i+ECHO_MAXAUDIOINPUTS));
+	  g_signal_connect(button, "toggled", G_CALLBACK(Nominal_level_toggled), (gpointer)(long)(i+ECHO_MAXAUDIOINPUTS));
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), !NominalOut.Level[i]);
     }
   }
@@ -2098,19 +2312,23 @@
     gtk_widget_show(hbox);
     gtk_container_add(GTK_CONTAINER(frame), hbox);
 
-    dmodeOpt=gtk_option_menu_new();
+//    dmodeOpt=gtk_option_menu_new();
+	dmodeOpt = gtk_combo_box_text_new();
     gtk_widget_show(dmodeOpt);
     menu=gtk_menu_new();
     gtk_widget_show(menu);
     for (i=0; i<ndmodes; i++) {
       menuitem=gtk_menu_item_new_with_label(dmodeName[i]);
       gtk_widget_show(menuitem);
-      gtk_signal_connect(GTK_OBJECT(menuitem), "activate", G_CALLBACK(Digital_mode_activate), (gpointer)(long)i);
-      gtk_menu_append(GTK_MENU(menu), menuitem);
+      //gtk_signal_connect(GTK_OBJECT(menuitem), "activate", G_CALLBACK(Digital_mode_activate), (gpointer)(long)i);
+	  g_signal_connect(menuitem, "activate", G_CALLBACK(Digital_mode_activate), (gpointer)(long)i);
+//      gtk_menu_append(GTK_MENU(menu), GTK_MENU_ITEM(menuitem));
+      gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
     }
-    gtk_option_menu_set_menu(GTK_OPTION_MENU(dmodeOpt), menu);
+//    gtk_option_menu_set_menu(GTK_COMBO_BOX(dmodeOpt), menu);
     gtk_box_pack_start(GTK_BOX(hbox), dmodeOpt, TRUE, TRUE, 0);
-    gtk_option_menu_set_history(GTK_OPTION_MENU(dmodeOpt), dmodeVal=GetEnum(dmodeId));
+//    gtk_option_menu_set_history(GTK_COMBO_BOX(dmodeOpt), dmodeVal=GetEnum(dmodeId));
+    gtk_combo_box_set_active(GTK_COMBO_BOX(dmodeOpt), dmodeVal=GetEnum(dmodeId));
   }
 
 
@@ -2123,7 +2341,8 @@
     gtk_widget_show(hbox);
     gtk_container_add(GTK_CONTAINER(frame), hbox);
 
-    clocksrcOpt=gtk_option_menu_new();
+//    clocksrcOpt=gtk_option_menu_new();
+    clocksrcOpt = gtk_combo_box_text_new();  // For a combo box with text items
     gtk_widget_show(clocksrcOpt);
     menu=gtk_menu_new();
     gtk_widget_show(menu);
@@ -2131,13 +2350,17 @@
       clocksrc_menuitem[i]=gtk_menu_item_new_with_label(clocksrcName[i]);
       gtk_widget_show(clocksrc_menuitem[i]);
       gtk_widget_set_sensitive(clocksrc_menuitem[i], FALSE);
-      gtk_signal_connect(GTK_OBJECT(clocksrc_menuitem[i]), "activate", G_CALLBACK(Clock_source_activate), (gpointer)(long)i);
-      gtk_menu_append(GTK_MENU(menu), clocksrc_menuitem[i]);
+      //gtk_signal_connect(GTK_OBJECT(clocksrc_menuitem[i]), "activate", G_CALLBACK(Clock_source_activate), (gpointer)(long)i);
+	  g_signal_connect(clocksrc_menuitem[i], "activate", G_CALLBACK(Clock_source_activate), (gpointer)(long)i);
+//      gtk_menu_append(GTK_MENU(menu), GTK_MENU_ITEM(clocksrc_menuitem[i]));
+      gtk_menu_shell_append(GTK_MENU_SHELL(menu), clocksrc_menuitem[i]);
     }
-    gtk_option_menu_set_menu(GTK_OPTION_MENU(clocksrcOpt), menu);
+//    gtk_option_menu_set_menu(GTK_COMBO_BOX(clocksrcOpt), menu);
     gtk_box_pack_start(GTK_BOX(hbox), clocksrcOpt, TRUE, TRUE, 0);
-    gtk_option_menu_set_history(GTK_OPTION_MENU(clocksrcOpt), clocksrcVal=GetEnum(clocksrcId));
-    clocksrctimer=gtk_timeout_add(2000, CheckInputs, 0);
+//    gtk_option_menu_set_history(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal=GetEnum(clocksrcId));
+    gtk_combo_box_set_active(GTK_COMBO_BOX(clocksrcOpt), clocksrcVal=GetEnum(clocksrcId));
+//    clocksrctimer=gtk_timeout_add(2000, CheckInputs, 0);
+    clocksrctimer=g_timeout_add(2000, CheckInputs, 0);
   }
 
 
@@ -2150,19 +2373,23 @@
     gtk_widget_show(hbox);
     gtk_container_add(GTK_CONTAINER(frame), hbox);
 
-    spdifmodeOpt=gtk_option_menu_new();
+//    spdifmodeOpt=gtk_option_menu_new();
+    spdifmodeOpt = gtk_combo_box_text_new();  // For a combo box with text items
     gtk_widget_show(spdifmodeOpt);
     menu=gtk_menu_new();
     gtk_widget_show(menu);
     for (i=0; i<nspdifmodes; i++) {
       menuitem=gtk_menu_item_new_with_label(spdifmodeName[i]);
       gtk_widget_show(menuitem);
-      gtk_signal_connect(GTK_OBJECT(menuitem), "activate", G_CALLBACK(SPDIF_mode_activate), (gpointer)(long)i);
-      gtk_menu_append(GTK_MENU(menu), menuitem);
+      //gtk_signal_connect(GTK_OBJECT(menuitem), "activate", G_CALLBACK(SPDIF_mode_activate), (gpointer)(long)i);
+	  g_signal_connect(menuitem, "activate", G_CALLBACK(SPDIF_mode_activate), (gpointer)(long)i);
+//      gtk_menu_append(GTK_MENU(menu), GTK_MENU_ITEM(menuitem));
+      gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
     }
-    gtk_option_menu_set_menu(GTK_OPTION_MENU(spdifmodeOpt), menu);
+//    gtk_option_menu_set_menu(GTK_COMBO_BOX(spdifmodeOpt), menu);
     gtk_box_pack_start(GTK_BOX(hbox), spdifmodeOpt, TRUE, TRUE, 0);
-    gtk_option_menu_set_history(GTK_OPTION_MENU(spdifmodeOpt), spdifmodeVal=GetEnum(spdifmodeId));
+//    gtk_option_menu_set_history(GTK_COMBO_BOX(spdifmodeOpt), spdifmodeVal=GetEnum(spdifmodeId));
+    gtk_combo_box_set_active(GTK_COMBO_BOX(spdifmodeOpt), spdifmodeVal=GetEnum(spdifmodeId));
   }
 
 
@@ -2182,7 +2409,8 @@
       gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, FALSE, 0);
       ReadControl(&i, 1, PhantomPower.id, SND_CTL_ELEM_IFACE_MIXER);
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), i);
-      gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(Switch_toggled), (gpointer)&PhantomPower);
+      //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(Switch_toggled), (gpointer)&PhantomPower);
+	  g_signal_connect(button, "toggled", G_CALLBACK(Switch_toggled), (gpointer)&PhantomPower);
       PhantomPower.Button=button;
     }
 
@@ -2193,7 +2421,8 @@
       gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, FALSE, 0);
       ReadControl(&i, 1, Automute.id, SND_CTL_ELEM_IFACE_CARD);
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), i);
-      gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(Switch_toggled), (gpointer)&Automute);
+      //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(Switch_toggled), (gpointer)&Automute);
+	  g_signal_connect(button, "toggled", G_CALLBACK(Switch_toggled), (gpointer)&Automute);
       Automute.Button=button;
     }
 
@@ -2202,7 +2431,8 @@
       autoclockChkbutton=gtk_check_button_new_with_label("Autoclock");
       gtk_widget_show(autoclockChkbutton);
       gtk_box_pack_start(GTK_BOX(hbox), autoclockChkbutton, TRUE, FALSE, 0);
-      gtk_signal_connect(GTK_OBJECT(autoclockChkbutton), "toggled", G_CALLBACK(AutoClock_toggled), NULL);
+      //gtk_signal_connect(GTK_OBJECT(autoclockChkbutton), "toggled", G_CALLBACK(AutoClock_toggled), NULL);
+	  g_signal_connect(autoclockChkbutton, "toggled", G_CALLBACK(AutoClock_toggled), NULL);
       AutoClock=-1;
     }
   }
@@ -2214,10 +2444,12 @@
   sprintf(str, "%s PCM volume", cardId);
   gtk_window_set_title(GTK_WINDOW (pcmoutControl.window), str);
   gtk_window_set_wmclass(GTK_WINDOW(pcmoutControl.window), "pcm", "Emixer");
-  gtk_signal_connect(GTK_OBJECT(pcmoutControl.window), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&PVw_geom);
+  //gtk_signal_connect(GTK_OBJECT(pcmoutControl.window), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&PVw_geom);
+  g_signal_connect(pcmoutControl.window, "delete_event", G_CALLBACK(CloseWindow), (gpointer)&PVw_geom);
   gtk_container_set_border_width(GTK_CONTAINER(pcmoutControl.window), BORDER);
   if (PVw_geom.st!=NOPOS) {
-    gtk_widget_set_uposition(pcmoutControl.window, PVw_geom.x, PVw_geom.y);
+//    gtk_widget_set_uposition(pcmoutControl.window, PVw_geom.x, PVw_geom.y);
+    gtk_window_move(GTK_WINDOW(pcmoutControl.window), PVw_geom.x, PVw_geom.y);
     gtk_window_set_default_size(GTK_WINDOW(pcmoutControl.window), PVw_geom.w, PVw_geom.h);
   }
 
@@ -2254,14 +2486,17 @@
       gtk_widget_show(pcmoutControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), pcmoutControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(pcmoutControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(pcmoutControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(PCM_volume_changed), (gpointer)(long)(i+ECHO_MAXAUDIOINPUTS));
+      //gtk_signal_connect(GTK_OBJECT(pcmoutControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(PCM_volume_changed), (gpointer)(long)(i+ECHO_MAXAUDIOINPUTS));
+	  g_signal_connect(pcmoutControl.adj[i], "value_changed", G_CALLBACK(PCM_volume_changed), (gpointer)(long)(i+ECHO_MAXAUDIOINPUTS));
       // Value label
       pcmoutControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(pcmoutControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), pcmoutControl.label[i], FALSE, FALSE, 0);
-      gtk_adjustment_set_value(GTK_ADJUSTMENT(pcmoutControl.adj[i]), value);
+      //gtk_adjustment_set_value(GTK_ADJUSTMENT(pcmoutControl.adj[i]), value);
+      gtk_adjustment_set_value(pcmoutControl.adj[i], value);
     }
-    gtk_widget_set_usize(GTK_WIDGET(pcmoutControl.volume[0]), 0, 170);		// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(pcmoutControl.volume[0]), 0, 170);		// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(pcmoutControl.volume[0]), -1, 170);  // Set minimum y size
   }
 
 
@@ -2271,10 +2506,12 @@
   sprintf(str, "%s Line volume", cardId);
   gtk_window_set_title(GTK_WINDOW (LVwindow), str);
   gtk_window_set_wmclass(GTK_WINDOW(LVwindow), "line", "Emixer");
-  gtk_signal_connect(GTK_OBJECT(LVwindow), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&LVw_geom);
+  //gtk_signal_connect(GTK_OBJECT(LVwindow), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&LVw_geom);
+  g_signal_connect(LVwindow, "delete_event", G_CALLBACK(CloseWindow), (gpointer)&LVw_geom);
   gtk_container_set_border_width(GTK_CONTAINER(LVwindow), BORDER);
   if (LVw_geom.st!=NOPOS) {
-    gtk_widget_set_uposition(LVwindow, LVw_geom.x, LVw_geom.y);
+//    gtk_widget_set_uposition(LVwindow, LVw_geom.x, LVw_geom.y);
+    gtk_window_move(GTK_WINDOW(LVwindow), LVw_geom.x, LVw_geom.y);
     gtk_window_set_default_size(GTK_WINDOW(LVwindow), LVw_geom.w, LVw_geom.h);
   }
 
@@ -2307,14 +2544,16 @@
       gtk_widget_show(lineinControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), lineinControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(lineinControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(lineinControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(PCM_volume_changed), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(lineinControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(PCM_volume_changed), (gpointer)(long)i);
+	  g_signal_connect(lineinControl.adj[i], "value_changed", G_CALLBACK(PCM_volume_changed), (gpointer)(long)i);
       // Value label
       lineinControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(lineinControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), lineinControl.label[i], FALSE, FALSE, 0);
       gtk_adjustment_set_value(GTK_ADJUSTMENT(lineinControl.adj[i]), value);
     }
-    gtk_widget_set_usize(GTK_WIDGET(lineinControl.volume[0]), 0, 170);	// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(lineinControl.volume[0]), 0, 170);	// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(lineinControl.volume[0]), 0, 170);	// Set minimum y size
   }
 
 
@@ -2346,14 +2585,16 @@
       gtk_widget_show(lineoutControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), lineoutControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(lineoutControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(lineoutControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(LineOut_volume_changed), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(lineoutControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(LineOut_volume_changed), (gpointer)(long)i);
+	  g_signal_connect(lineoutControl.adj[i], "value_changed", G_CALLBACK(LineOut_volume_changed), (gpointer)(long)i);
       // Value label
       lineoutControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(lineoutControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), lineoutControl.label[i], FALSE, FALSE, 0);
       gtk_adjustment_set_value(GTK_ADJUSTMENT(lineoutControl.adj[i]), value);
     }
-    gtk_widget_set_usize(GTK_WIDGET(lineoutControl.volume[0]), 0, 170);		// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(lineoutControl.volume[0]), 0, 170);		// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(lineoutControl.volume[0]), 0, 170);		// Set minimum y size
   }
 
 
@@ -2365,10 +2606,12 @@
     sprintf(str, "%s Monitor mixer", cardId);
     gtk_window_set_title(GTK_WINDOW(mixerControl.window), str);
     gtk_window_set_wmclass(GTK_WINDOW(mixerControl.window), "mixer", "Emixer");
-    gtk_signal_connect(GTK_OBJECT(mixerControl.window), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&Mixerw_geom);
+    //gtk_signal_connect(GTK_OBJECT(mixerControl.window), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&Mixerw_geom);
+    g_signal_connect(mixerControl.window, "delete_event", G_CALLBACK(CloseWindow), (gpointer)&Mixerw_geom);
     gtk_container_set_border_width(GTK_CONTAINER(mixerControl.window), BORDER);
     if (Mixerw_geom.st!=NOPOS) {
-      gtk_widget_set_uposition(mixerControl.window, Mixerw_geom.x, Mixerw_geom.y);
+//      gtk_widget_set_uposition(mixerControl.window, Mixerw_geom.x, Mixerw_geom.y);
+      gtk_window_move(GTK_WINDOW(mixerControl.window), Mixerw_geom.x, Mixerw_geom.y);
       gtk_window_set_default_size(GTK_WINDOW(mixerControl.window), Mixerw_geom.w, Mixerw_geom.h);
 //      gdk_window_move_resize(mixerControl.window->window, Mixerw_geom.x, Mixerw_geom.y, Mixerw_geom.w, Mixerw_geom.h);
 /*      gtk_widget_set_usize(mixerControl.window, Mixerw_geom.w, Mixerw_geom.h);
@@ -2406,14 +2649,17 @@
       gtk_widget_show(mixerControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), mixerControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(mixerControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(mixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Monitor_volume_clicked), (gpointer)i);
-      gtk_signal_connect(GTK_OBJECT(mixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Monitor_volume_changed), (gpointer)i);
+      //gtk_signal_connect(GTK_OBJECT(mixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Monitor_volume_clicked), (gpointer)i);
+	  g_signal_connect(mixerControl.volume[i], "grab_focus", G_CALLBACK(Monitor_volume_clicked), (gpointer)i);
+      //gtk_signal_connect(GTK_OBJECT(mixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Monitor_volume_changed), (gpointer)i);
+	  g_signal_connect(mixerControl.adj[i], "value_changed", G_CALLBACK(Monitor_volume_changed), (gpointer)i);
       // Value label
       mixerControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(mixerControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), mixerControl.label[i], FALSE, FALSE, 0);
     }
-    gtk_widget_set_usize(GTK_WIDGET(mixerControl.volume[0]), 0, 170);		// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(mixerControl.volume[0]), 0, 170);		// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(mixerControl.volume[0]), 0, 170);		// Set minimum y size
 
     // Output channel selectors
     frame=gtk_frame_new("Mixer output");
@@ -2429,12 +2675,19 @@
         sprintf(str, "An-%d", i);
       else
         sprintf(str, "Di-%d", i-fdOut);
-      if (i)
-        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(mixerControl.outsel[i-1]));
-      mixerControl.outsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+//      if (i)
+//        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(mixerControl.outsel[i-1]));
+//      mixerControl.outsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+      if (i == 0)
+        // For the first radio button, create it without a group (it will be its own group).
+        mixerControl.outsel[i] = gtk_radio_button_new_with_label(NULL, str);
+      else
+        // For subsequent radio buttons, create and group them with the first one.
+        mixerControl.outsel[i] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(mixerControl.outsel[0]), str);
       gtk_widget_show(mixerControl.outsel[i]);
       gtk_box_pack_start(GTK_BOX(vbsel), mixerControl.outsel[i], FALSE, FALSE, 0);
-      gtk_signal_connect(GTK_OBJECT(mixerControl.outsel[i]), "toggled", GTK_SIGNAL_FUNC(Mixer_Output_selector_clicked), (gpointer)i);
+      //gtk_signal_connect(GTK_OBJECT(mixerControl.outsel[i]), "toggled", GTK_SIGNAL_FUNC(Mixer_Output_selector_clicked), (gpointer)i);
+	  g_signal_connect(mixerControl.outsel[i], "toggled", G_CALLBACK(Mixer_Output_selector_clicked), (gpointer)i);
     }
     mixerControl.input=0;
     mixerControl.output=-1;
@@ -2456,12 +2709,19 @@
         sprintf(str, "An-%d", i);
       else
         sprintf(str, "Di-%d", i-fdIn);
-      if (i)
-        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(mixerControl.inpsel[i-1]));
-      mixerControl.inpsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+//      if (i)
+//        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(mixerControl.inpsel[i-1]));
+//      mixerControl.inpsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+      if (i == 0)
+        // For the first radio button, create it without a group (it will be its own group).
+        mixerControl.inpsel[i] = gtk_radio_button_new_with_label(NULL, str);
+      else
+        // For subsequent radio buttons, create and group them with the first one.
+        mixerControl.inpsel[i] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(mixerControl.inpsel[0]), str);
       gtk_widget_show(mixerControl.inpsel[i]);
       gtk_box_pack_start(GTK_BOX(vbsel), mixerControl.inpsel[i], FALSE, FALSE, 0);
-      gtk_signal_connect(GTK_OBJECT(mixerControl.inpsel[i]), "toggled", GTK_SIGNAL_FUNC(Mixer_Input_selector_clicked), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(mixerControl.inpsel[i]), "toggled", GTK_SIGNAL_FUNC(Mixer_Input_selector_clicked), (gpointer)(long)i);
+	  g_signal_connect(mixerControl.inpsel[i], "toggled", G_CALLBACK(Mixer_Input_selector_clicked), (gpointer)(long)i);
     }
 
     // Mixer volume widgets
@@ -2490,14 +2750,17 @@
       gtk_widget_show(mixerControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), mixerControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(mixerControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(mixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Monitor_volume_clicked), (gpointer)(long)i);
-      gtk_signal_connect(GTK_OBJECT(mixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Monitor_volume_changed), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(mixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Monitor_volume_clicked), (gpointer)(long)i);
+	  g_signal_connect(mixerControl.volume[i], "grab_focus", G_CALLBACK(Monitor_volume_clicked), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(mixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Monitor_volume_changed), (gpointer)(long)i);
+	  g_signal_connect(mixerControl.adj[i], "value_changed", G_CALLBACK(Monitor_volume_changed), (gpointer)(long)i);
       // Value label
       mixerControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(mixerControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), mixerControl.label[i], FALSE, FALSE, 0);
     }
-    gtk_widget_set_usize(GTK_WIDGET(mixerControl.volume[0]), 0, 170);		// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(mixerControl.volume[0]), 0, 170);		// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(mixerControl.volume[0]), 0, 170);		// Set minimum y size
     mixerControl.input=-1;
     mixerControl.output=0;
     Mixer_Input_selector_clicked(0, 0);
@@ -2512,10 +2775,12 @@
     sprintf(str, "%s Vmixer", cardId);
     gtk_window_set_title(GTK_WINDOW(vmixerControl.window), str);
     gtk_window_set_wmclass(GTK_WINDOW(vmixerControl.window), "vmixer", "Emixer");
-    gtk_signal_connect(GTK_OBJECT(vmixerControl.window), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&Vmixerw_geom);
+    //gtk_signal_connect(GTK_OBJECT(vmixerControl.window), "delete_event", GTK_SIGNAL_FUNC(CloseWindow), (gpointer)&Vmixerw_geom);
+    g_signal_connect(vmixerControl.window, "delete_event", G_CALLBACK(CloseWindow), (gpointer)&Vmixerw_geom);
     gtk_container_set_border_width(GTK_CONTAINER(vmixerControl.window), BORDER);
     if (Vmixerw_geom.st!=NOPOS) {
-      gtk_widget_set_uposition(vmixerControl.window, Vmixerw_geom.x, Vmixerw_geom.y);
+//      gtk_widget_set_uposition(vmixerControl.window, Vmixerw_geom.x, Vmixerw_geom.y);
+      gtk_window_move(GTK_WINDOW(vmixerControl.window), Vmixerw_geom.x, Vmixerw_geom.y);
       gtk_window_set_default_size(GTK_WINDOW(vmixerControl.window), Vmixerw_geom.w, Vmixerw_geom.h);
     }
 
@@ -2548,14 +2813,17 @@
       gtk_widget_show(vmixerControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), vmixerControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(vmixerControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(vmixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Vmixer_volume_clicked), (gpointer)i);
-      gtk_signal_connect(GTK_OBJECT(vmixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Vmixer_volume_changed), (gpointer)i);
+      //gtk_signal_connect(GTK_OBJECT(vmixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Vmixer_volume_clicked), (gpointer)i);
+	  g_signal_connect(vmixerControl.volume[i], "grab_focus", G_CALLBACK(Vmixer_volume_clicked), (gpointer)i);
+      //gtk_signal_connect(GTK_OBJECT(vmixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Vmixer_volume_changed), (gpointer)i);
+	  g_signal_connect(vmixerControl.adj[i], "value_changed", G_CALLBACK(Vmixer_volume_changed), (gpointer)i);
       // Value label
       vmixerControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(vmixerControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), vmixerControl.label[i], FALSE, FALSE, 0);
     }
-    gtk_widget_set_usize(GTK_WIDGET(vmixerControl.volume[0]), 0, 170);		// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(vmixerControl.volume[0]), 0, 170);		// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(vmixerControl.volume[0]), 0, 170);		// Set minimum y size
 
     // Input channel selectors
     frame=gtk_frame_new("Output");
@@ -2571,12 +2839,19 @@
         sprintf(str, "A%d", i);
       else
         sprintf(str, "D%d", i);
-      if (i)
-        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(vmixerControl.outsel[i-1]));
-      vmixerControl.outsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+//      if (i)
+//        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(vmixerControl.outsel[i-1]));
+//      vmixerControl.outsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+      if (i == 0)
+        // For the first radio button, create it without a group (it will be its own group).
+        vmixerControl.outsel[i] = gtk_radio_button_new_with_label(NULL, str);
+      else
+        // For subsequent radio buttons, create and group them with the first one.
+        vmixerControl.outsel[i] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(vmixerControl.outsel[0]), str);
       gtk_widget_show(vmixerControl.outsel[i]);
       gtk_box_pack_start(GTK_BOX(vbsel), vmixerControl.outsel[i], FALSE, FALSE, 0);
-      gtk_signal_connect(GTK_OBJECT(vmixerControl.outsel[i]), "toggled", GTK_SIGNAL_FUNC(Vmixer_output_selector_clicked), (gpointer)i);
+      //gtk_signal_connect(GTK_OBJECT(vmixerControl.outsel[i]), "toggled", GTK_SIGNAL_FUNC(Vmixer_output_selector_clicked), (gpointer)i);
+	  g_signal_connect(vmixerControl.outsel[i], "toggled", G_CALLBACK(Vmixer_output_selector_clicked), (gpointer)i);
     }
     vmixerControl.output=-1;
     Vmixer_output_selector_clicked(0, 0);
@@ -2594,12 +2869,19 @@
     bgroup=0;
     for (i=0; i<vmixerControl.inputs; i++) {
       sprintf(str, "V%d", i);
-      if (i)
-        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(vmixerControl.vchsel[i-1]));
-      vmixerControl.vchsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+//      if (i)
+//        bgroup=gtk_radio_button_group(GTK_RADIO_BUTTON(vmixerControl.vchsel[i-1]));
+//      vmixerControl.vchsel[i]=gtk_radio_button_new_with_label(bgroup, str);
+      if (i == 0)
+        // For the first radio button, create it without a group (it will be its own group).
+        vmixerControl.vchsel[i] = gtk_radio_button_new_with_label(NULL, str);
+      else
+        // For subsequent radio buttons, create and group them with the previous button.
+        vmixerControl.vchsel[i] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(vmixerControl.vchsel[i-1]), str);
       gtk_widget_show(vmixerControl.vchsel[i]);
       gtk_box_pack_start(GTK_BOX(vbsel), vmixerControl.vchsel[i], FALSE, FALSE, 0);
-      gtk_signal_connect(GTK_OBJECT(vmixerControl.vchsel[i]), "toggled", GTK_SIGNAL_FUNC(Vmixer_vchannel_selector_clicked), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(vmixerControl.vchsel[i]), "toggled", GTK_SIGNAL_FUNC(Vmixer_vchannel_selector_clicked), (gpointer)(long)i);
+	  g_signal_connect(vmixerControl.vchsel[i], "toggled", G_CALLBACK(Vmixer_vchannel_selector_clicked), (gpointer)(long)i);
     }
 
     // Vmixer volume widgets
@@ -2628,14 +2910,17 @@
       gtk_widget_show(vmixerControl.volume[i]);
       gtk_box_pack_start(GTK_BOX(vbox), vmixerControl.volume[i], TRUE, TRUE, 0);
       gtk_scale_set_draw_value(GTK_SCALE(vmixerControl.volume[i]), 0);
-      gtk_signal_connect(GTK_OBJECT(vmixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Vmixer_volume_clicked), (gpointer)(long)i);
-      gtk_signal_connect(GTK_OBJECT(vmixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Vmixer_volume_changed), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(vmixerControl.volume[i]), "grab_focus", GTK_SIGNAL_FUNC(Vmixer_volume_clicked), (gpointer)(long)i);
+	  g_signal_connect(vmixerControl.volume[i], "grab_focus", G_CALLBACK(Vmixer_volume_clicked), (gpointer)(long)i);
+      //gtk_signal_connect(GTK_OBJECT(vmixerControl.adj[i]), "value_changed", GTK_SIGNAL_FUNC(Vmixer_volume_changed), (gpointer)(long)i);
+	  g_signal_connect(vmixerControl.adj[i], "value_changed", G_CALLBACK(Vmixer_volume_changed), (gpointer)(long)i);
       // Value label
       vmixerControl.label[i]=gtk_label_new("xxx");
       gtk_widget_show(vmixerControl.label[i]);
       gtk_box_pack_start(GTK_BOX(vbox), vmixerControl.label[i], FALSE, FALSE, 0);
     }
-    gtk_widget_set_usize(GTK_WIDGET(vmixerControl.volume[0]), 0, 170);		// Set minimum y size
+//    gtk_widget_set_usize(GTK_WIDGET(vmixerControl.volume[0]), 0, 170);		// Set minimum y size
+    gtk_widget_set_size_request(GTK_WIDGET(vmixerControl.volume[0]), 0, 170);		// Set minimum y size
     vmixerControl.input=-1;
     Vmixer_vchannel_selector_clicked(0, 0);
 #endif
@@ -2648,11 +2933,13 @@
   sprintf(str, EM_VERSION, cardId);
   gtk_window_set_title(GTK_WINDOW(Mainwindow), str);
   gtk_window_set_wmclass(GTK_WINDOW(Mainwindow), "emixer", "Emixer");
-  gtk_signal_connect(GTK_OBJECT(Mainwindow), "delete_event", GTK_SIGNAL_FUNC(Mainwindow_delete), (gpointer)&Mainw_geom);
+  //gtk_signal_connect(GTK_OBJECT(Mainwindow), "delete_event", GTK_SIGNAL_FUNC(Mainwindow_delete), (gpointer)&Mainw_geom);
+  g_signal_connect(Mainwindow, "delete_event", G_CALLBACK(Mainwindow_delete), (gpointer)&Mainw_geom);
   gtk_container_set_border_width(GTK_CONTAINER(Mainwindow), BORDER);
   gtk_widget_show(Mainwindow);
   if (Mainw_geom.x!=NOPOS) {
-    gtk_widget_set_uposition(Mainwindow, Mainw_geom.x, Mainw_geom.y);
+//    gtk_widget_set_uposition(Mainwindow, Mainw_geom.x, Mainw_geom.y);
+    gtk_window_move(GTK_WINDOW(Mainwindow), Mainw_geom.x, Mainw_geom.y);
     gtk_window_set_default_size(GTK_WINDOW(Mainwindow), Mainw_geom.w, Mainw_geom.h);
   }
 
@@ -2672,7 +2959,8 @@
   gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 0);
   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), 1);
   gtk_widget_show(button);
-  gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(Gang_button_toggled), 0);
+  //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(Gang_button_toggled), 0);
+  g_signal_connect(button, "toggled", G_CALLBACK(Gang_button_toggled), 0);
 
   // Controls frame
   frame=gtk_frame_new("Controls");
@@ -2687,7 +2975,8 @@
     button=gtk_toggle_button_new_with_label("VU");
     gtk_widget_show(button);
     gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-    gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(VUmeters_button_click), 0);
+    //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(VUmeters_button_click), 0);
+    g_signal_connect(button, "toggled", G_CALLBACK(VUmeters_button_click), 0);
     VUw_geom.toggler=button;
     if (VUw_geom.st==1)
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2697,7 +2986,8 @@
   button=gtk_toggle_button_new_with_label("Line");
   gtk_widget_show(button);
   gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-  gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)LVwindow);
+  //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)LVwindow);
+  g_signal_connect(button, "toggled", G_CALLBACK(ToggleWindow), (gpointer)LVwindow);
   LVw_geom.toggler=button;
   if (LVw_geom.st==1)
     gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2707,7 +2997,8 @@
     button=gtk_toggle_button_new_with_label("Misc");
     gtk_widget_show(button);
     gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-    gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)Miscwindow);
+    //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)Miscwindow);
+    g_signal_connect(button, "toggled", G_CALLBACK(ToggleWindow), (gpointer)Miscwindow);
     Miscw_geom.toggler=button;
     if (Miscw_geom.st==1)
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2718,7 +3009,8 @@
     button=gtk_toggle_button_new_with_label("GrMix");
     gtk_widget_show(button);
     gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-    gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(GMixer_button_click), 0);
+    //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(GMixer_button_click), 0);
+    g_signal_connect(button, "toggled", G_CALLBACK(GMixer_button_click), 0);
     GMw_geom.toggler=button;
     if (GMw_geom.st==1)
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2727,7 +3019,8 @@
     button=gtk_toggle_button_new_with_label("Mixer");
     gtk_widget_show(button);
     gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-    gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)mixerControl.window);
+    //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)mixerControl.window);
+    g_signal_connect(button, "toggled", G_CALLBACK(ToggleWindow), (gpointer)mixerControl.window);
     Mixerw_geom.toggler=button;
     if (Mixerw_geom.st==1)
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2738,7 +3031,8 @@
     button=gtk_toggle_button_new_with_label("Vmixer");
     gtk_widget_show(button);
     gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-    gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)vmixerControl.window);
+    //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)vmixerControl.window);
+    g_signal_connect(button, "toggled", G_CALLBACK(ToggleWindow), (gpointer)vmixerControl.window);
     Vmixerw_geom.toggler=button;
     if (Vmixerw_geom.st==1)
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2749,7 +3043,8 @@
     button=gtk_toggle_button_new_with_label("PCM");
     gtk_widget_show(button);
     gtk_box_pack_start(GTK_BOX(hbox), button, TRUE, TRUE, 1);
-    gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)pcmoutControl.window);
+    //gtk_signal_connect(GTK_OBJECT(button), "toggled", G_CALLBACK(ToggleWindow), (gpointer)pcmoutControl.window);
+    g_signal_connect(button, "toggled", G_CALLBACK(ToggleWindow), (gpointer)pcmoutControl.window);
     PVw_geom.toggler=button;
     if (PVw_geom.st==1)
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
@@ -2805,41 +3100,74 @@
         fprintf(f, "-- xxWindow <x> <y> <width> <height> <visible>\n");
         fprintf(f, "MainWindow %d %d %d %d\n", Mainw_geom.x, Mainw_geom.y, Mainw_geom.w, Mainw_geom.h);
         if (VUwindow)
-          gdk_window_get_root_origin(VUwindow->window, &VUw_geom.x, &VUw_geom.y);
+//          //gdk_window_get_root_origin(VUwindow->window, &VUw_geom.x, &VUw_geom.y);
+//          gdk_window_get_root_origin(gtk_widget_get_window(VUwindow), &VUw_geom.x, &VUw_geom.y);
+          //gdk_window_get_root_origin(gtk_widget_get_window(VUwindow), &VUw_geom.x, &VUw_geom.y);
+          gdk_window_get_root_origin(gtk_widget_get_window(VUwindow), &VUw_geom.x, &VUw_geom.y);
         fprintf(f, "VUmetersWindow %d %d %d\n", VUw_geom.x, VUw_geom.y, VUw_geom.st);
         if (GMwindow)
-          gdk_window_get_root_origin(GMwindow->window, &VUw_geom.x, &VUw_geom.y);
+//          //gdk_window_get_root_origin(GMwindow->window, &VUw_geom.x, &VUw_geom.y);
+//          gdk_window_get_root_origin(gtk_widget_get_window(GMwindow), &VUw_geom.x, &VUw_geom.y);
+          //gdk_window_get_root_origin(gtk_widget_get_window(GMwindow), &VUw_geom.x, &VUw_geom.y);
+          gdk_window_get_root_origin(gtk_widget_get_window(GMwindow), &VUw_geom.x, &VUw_geom.y);
         fprintf(f, "GfxMixerWindow %d %d %d\n", GMw_geom.x, GMw_geom.y, GMw_geom.st);
         if (pcmoutId) {
-          if (pcmoutControl.window->window) {
-            gdk_window_get_root_origin(pcmoutControl.window->window, &PVw_geom.x, &PVw_geom.y);
-            gdk_window_get_size(pcmoutControl.window->window, &PVw_geom.w, &PVw_geom.h);
+//          if (pcmoutControl.window->window) {
+		// Get the GdkWindow* from the GtkWidget
+		GdkWindow* pcmwin = gtk_widget_get_window(pcmoutControl.window);
+		  if (pcmwin) {
+//            //gdk_window_get_root_origin(pcmoutControl.window->window, &PVw_geom.x, &PVw_geom.y);
+//            gdk_window_get_root_origin(gtk_widget_get_window(pcmoutControl.window), &PVw_geom.x, &PVw_geom.y);
+//            //gdk_window_get_size(pcmoutControl.window->window, &PVw_geom.w, &PVw_geom.h);
+//            gdk_window_get_size(GTK_WINDOW(pcmoutControl.window), &PVw_geom.w, &PVw_geom.h);
+            //gdk_window_get_root_origin(pcmwin, &PVw_geom.x, &PVw_geom.y);
+            gdk_window_get_root_origin(pcmwin, &PVw_geom.x, &PVw_geom.y);
+            //gdk_window_get_size(pcmwin, &PVw_geom.w, &PVw_geom.h);
+			// Cast the GtkWidget to GtkWindow* and then call gtk_window_get_size
+			gtk_window_get_size(GTK_WINDOW(pcmoutControl.window), &PVw_geom.w, &PVw_geom.h);
           }
-          fprintf(f, "PcmVolumeWindow %d %d %d %d %d\n", PVw_geom.x, PVw_geom.y, PVw_geom.w, PVw_geom.h, !!GTK_WIDGET_VISIBLE(pcmoutControl.window));
+//          fprintf(f, "PcmVolumeWindow %d %d %d %d %d\n", PVw_geom.x, PVw_geom.y, PVw_geom.w, PVw_geom.h, !!GTK_WIDGET_VISIBLE(pcmoutControl.window));
+          fprintf(f, "PcmVolumeWindow %d %d %d %d %d\n", PVw_geom.x, PVw_geom.y, PVw_geom.w, PVw_geom.h, !!gtk_widget_get_visible(pcmoutControl.window));
         }
-        if (LVwindow->window) {
-          gdk_window_get_root_origin(LVwindow->window, &LVw_geom.x, &LVw_geom.y);
-          gdk_window_get_size(LVwindow->window, &LVw_geom.w, &LVw_geom.h);
+//        if (LVwindow->window) {
+        if (LVwindow) {
+          //gdk_window_get_root_origin(LVwindow->window, &LVw_geom.x, &LVw_geom.y);
+          gdk_window_get_root_origin(gtk_widget_get_window(LVwindow), &LVw_geom.x, &LVw_geom.y);
+          //gdk_window_get_size(LVwindow->window, &LVw_geom.w, &LVw_geom.h);
+          gtk_window_get_size(GTK_WINDOW(LVwindow), &LVw_geom.w, &LVw_geom.h);
         }
-        fprintf(f, "LineVolumeWindow %d %d %d %d %d\n", LVw_geom.x, LVw_geom.y, LVw_geom.w, LVw_geom.h, !!GTK_WIDGET_VISIBLE(LVwindow));
-        if (Miscwindow->window) {
-          gdk_window_get_root_origin(Miscwindow->window, &Miscw_geom.x, &Miscw_geom.y);
-          gdk_window_get_size(Miscwindow->window, &Miscw_geom.w, &Miscw_geom.h);
+//        fprintf(f, "LineVolumeWindow %d %d %d %d %d\n", LVw_geom.x, LVw_geom.y, LVw_geom.w, LVw_geom.h, !!GTK_WIDGET_VISIBLE(LVwindow));
+        fprintf(f, "LineVolumeWindow %d %d %d %d %d\n", LVw_geom.x, LVw_geom.y, LVw_geom.w, LVw_geom.h, !!gtk_widget_get_visible(LVwindow));
+//        if (Miscwindow->window) {
+        if (Miscwindow) {
+          //gdk_window_get_root_origin(Miscwindow->window, &Miscw_geom.x, &Miscw_geom.y);
+          gdk_window_get_root_origin(gtk_widget_get_window(Miscwindow), &Miscw_geom.x, &Miscw_geom.y);
+          //gdk_window_get_size(Miscwindow->window, &Miscw_geom.w, &Miscw_geom.h);
+          gtk_window_get_size(GTK_WINDOW(Miscwindow), &Miscw_geom.w, &Miscw_geom.h);
         }
-        fprintf(f, "MiscControlsWindow %d %d %d %d %d\n", Miscw_geom.x, Miscw_geom.y, Miscw_geom.w, Miscw_geom.h, !!GTK_WIDGET_VISIBLE(Miscwindow));
+//        fprintf(f, "MiscControlsWindow %d %d %d %d %d\n", Miscw_geom.x, Miscw_geom.y, Miscw_geom.w, Miscw_geom.h, !!GTK_WIDGET_VISIBLE(Miscwindow));
+        fprintf(f, "MiscControlsWindow %d %d %d %d %d\n", Miscw_geom.x, Miscw_geom.y, Miscw_geom.w, Miscw_geom.h, !!gtk_widget_get_visible(Miscwindow));
         if (mixerId) {
-          if (mixerControl.window->window) {
-            gdk_window_get_root_origin(mixerControl.window->window, &Mixerw_geom.x, &Mixerw_geom.y);
-            gdk_window_get_size(mixerControl.window->window, &Mixerw_geom.w, &Mixerw_geom.h);
+//          if (mixerControl.window->window) {
+          if (mixerControl.window) {
+            //gdk_window_get_root_origin(mixerControl.window->window, &Mixerw_geom.x, &Mixerw_geom.y);
+            gdk_window_get_root_origin(gtk_widget_get_window(mixerControl.window), &Mixerw_geom.x, &Mixerw_geom.y);
+            //gdk_window_get_size(mixerControl.window->window, &Mixerw_geom.w, &Mixerw_geom.h);
+            gtk_window_get_size(GTK_WINDOW(mixerControl.window), &Mixerw_geom.w, &Mixerw_geom.h);
           }
-          fprintf(f, "MixerWindow %d %d %d %d %d\n", Mixerw_geom.x, Mixerw_geom.y, Mixerw_geom.w, Mixerw_geom.h, !!GTK_WIDGET_VISIBLE(mixerControl.window));
+//          fprintf(f, "MixerWindow %d %d %d %d %d\n", Mixerw_geom.x, Mixerw_geom.y, Mixerw_geom.w, Mixerw_geom.h, !!GTK_WIDGET_VISIBLE(mixerControl.window));
+          fprintf(f, "MixerWindow %d %d %d %d %d\n", Mixerw_geom.x, Mixerw_geom.y, Mixerw_geom.w, Mixerw_geom.h, !!gtk_widget_get_visible(mixerControl.window));
         }
         if (vmixerId) {
-          if (vmixerControl.window->window) {
-            gdk_window_get_root_origin(vmixerControl.window->window, &Vmixerw_geom.x, &Vmixerw_geom.y);
-            gdk_window_get_size(vmixerControl.window->window, &Vmixerw_geom.w, &Vmixerw_geom.h);
+//          if (vmixerControl.window->window) {
+          if (vmixerControl.window) {
+            //gdk_window_get_root_origin(vmixerControl.window->window, &Vmixerw_geom.x, &Vmixerw_geom.y);
+            gdk_window_get_root_origin(gtk_widget_get_window(vmixerControl.window), &Vmixerw_geom.x, &Vmixerw_geom.y);
+            //gdk_window_get_size(vmixerControl.window->window, &Vmixerw_geom.w, &Vmixerw_geom.h);
+            gtk_window_get_size(GTK_WINDOW(vmixerControl.window), &Vmixerw_geom.w, &Vmixerw_geom.h);
           }
-          fprintf(f, "VmixerWindow %d %d %d %d %d\n", Vmixerw_geom.x, Vmixerw_geom.y, Vmixerw_geom.w, Vmixerw_geom.h, !!GTK_WIDGET_VISIBLE(vmixerControl.window));
+//          fprintf(f, "VmixerWindow %d %d %d %d %d\n", Vmixerw_geom.x, Vmixerw_geom.y, Vmixerw_geom.w, Vmixerw_geom.h, !!GTK_WIDGET_VISIBLE(vmixerControl.window));
+          fprintf(f, "VmixerWindow %d %d %d %d %d\n", Vmixerw_geom.x, Vmixerw_geom.y, Vmixerw_geom.w, Vmixerw_geom.h, !!gtk_widget_get_visible(vmixerControl.window));
         }
         fprintf(f, "\n");
         fclose(f);
@@ -2849,11 +3177,13 @@
 
   if (VUwindow) {
     SetVUmeters(0);
-    gtk_timeout_remove(VUtimer);
+    //gtk_timeout_remove(VUtimer);
+    g_source_remove(VUtimer);
   }
   if (GMwindow) {
     SetVUmeters(0);
-    gtk_timeout_remove(Mixtimer);
+    //gtk_timeout_remove(Mixtimer);
+    g_source_remove(Mixtimer);
   }
   snd_ctl_close(ctlhandle);
   return(0);
